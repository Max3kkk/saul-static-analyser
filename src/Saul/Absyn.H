/* File generated by the BNF Converter (bnfc 2.9.4.1). */

#ifndef SAUL_ABSYN_HEADER
#define SAUL_ABSYN_HEADER

#include<string>
#include<vector>

//C++ Abstract Syntax Interface.
namespace Saul
{
/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef std::string String;
typedef std::string Ident;


typedef std::string SaulIdent;


/********************   Forward Declarations    ********************/

class Program;
class LanguageDecl;
class Decl;
class LocalDecl;
class Annotation;
class ParamDecl;
class ReturnType;
class Type;
class MatchCase;
class Pattern;
class LabelledPattern;
class Binding;
class Expr;
class RecordFieldType;
class AProgram;
class LanguageCore;
class DeclFun;
class ALocalDecl;
class InlineAnnotation;
class AParamDecl;
class NoReturnType;
class SomeReturnType;
class AMatchCase;
class PatternInl;
class PatternInr;
class PatternTuple;
class PatternRecord;
class PatternFalse;
class PatternTrue;
class PatternUnit;
class PatternInt;
class PatternSucc;
class PatternVar;
class ALabelledPattern;
class ABinding;
class Sequence;
class Assign;
class If;
class LessThan;
class LessThanOrEqual;
class GreaterThan;
class GreaterThanOrEqual;
class Equal;
class NotEqual;
class Abstraction;
class Match;
class Add;
class Subtract;
class LogicOr;
class Multiply;
class Divide;
class LogicAnd;
class Ref;
class Deref;
class Application;
class DotRecord;
class DotTuple;
class Tuple;
class Record;
class Panic;
class Inl;
class Inr;
class Succ;
class LogicNot;
class Pred;
class IsZero;
class NatRec;
class ConstTrue;
class ConstFalse;
class ConstUnit;
class ConstInt;
class Var;
class TypeFun;
class TypeSum;
class TypeTuple;
class TypeRecord;
class TypeBool;
class TypeNat;
class TypeUnit;
class TypeTop;
class TypeBottom;
class TypeRef;
class TypeVar;
class ARecordFieldType;
class ListSaulIdent;
class ListDecl;
class ListLocalDecl;
class ListAnnotation;
class ListParamDecl;
class ListType;
class ListMatchCase;
class ListPattern;
class ListLabelledPattern;
class ListBinding;
class ListExpr;
class ListRecordFieldType;


/********************   Visitor Interfaces    ********************/
class Visitor
{
public:
  virtual ~Visitor() {}
  virtual void visitProgram(Program *p) = 0;
  virtual void visitLanguageDecl(LanguageDecl *p) = 0;
  virtual void visitDecl(Decl *p) = 0;
  virtual void visitLocalDecl(LocalDecl *p) = 0;
  virtual void visitAnnotation(Annotation *p) = 0;
  virtual void visitParamDecl(ParamDecl *p) = 0;
  virtual void visitReturnType(ReturnType *p) = 0;
  virtual void visitType(Type *p) = 0;
  virtual void visitMatchCase(MatchCase *p) = 0;
  virtual void visitPattern(Pattern *p) = 0;
  virtual void visitLabelledPattern(LabelledPattern *p) = 0;
  virtual void visitBinding(Binding *p) = 0;
  virtual void visitExpr(Expr *p) = 0;
  virtual void visitRecordFieldType(RecordFieldType *p) = 0;
  virtual void visitAProgram(AProgram *p) = 0;
  virtual void visitLanguageCore(LanguageCore *p) = 0;
  virtual void visitDeclFun(DeclFun *p) = 0;
  virtual void visitALocalDecl(ALocalDecl *p) = 0;
  virtual void visitInlineAnnotation(InlineAnnotation *p) = 0;
  virtual void visitAParamDecl(AParamDecl *p) = 0;
  virtual void visitNoReturnType(NoReturnType *p) = 0;
  virtual void visitSomeReturnType(SomeReturnType *p) = 0;
  virtual void visitAMatchCase(AMatchCase *p) = 0;
  virtual void visitPatternInl(PatternInl *p) = 0;
  virtual void visitPatternInr(PatternInr *p) = 0;
  virtual void visitPatternTuple(PatternTuple *p) = 0;
  virtual void visitPatternRecord(PatternRecord *p) = 0;
  virtual void visitPatternFalse(PatternFalse *p) = 0;
  virtual void visitPatternTrue(PatternTrue *p) = 0;
  virtual void visitPatternUnit(PatternUnit *p) = 0;
  virtual void visitPatternInt(PatternInt *p) = 0;
  virtual void visitPatternSucc(PatternSucc *p) = 0;
  virtual void visitPatternVar(PatternVar *p) = 0;
  virtual void visitALabelledPattern(ALabelledPattern *p) = 0;
  virtual void visitABinding(ABinding *p) = 0;
  virtual void visitSequence(Sequence *p) = 0;
  virtual void visitAssign(Assign *p) = 0;
  virtual void visitIf(If *p) = 0;
  virtual void visitLessThan(LessThan *p) = 0;
  virtual void visitLessThanOrEqual(LessThanOrEqual *p) = 0;
  virtual void visitGreaterThan(GreaterThan *p) = 0;
  virtual void visitGreaterThanOrEqual(GreaterThanOrEqual *p) = 0;
  virtual void visitEqual(Equal *p) = 0;
  virtual void visitNotEqual(NotEqual *p) = 0;
  virtual void visitAbstraction(Abstraction *p) = 0;
  virtual void visitMatch(Match *p) = 0;
  virtual void visitAdd(Add *p) = 0;
  virtual void visitSubtract(Subtract *p) = 0;
  virtual void visitLogicOr(LogicOr *p) = 0;
  virtual void visitMultiply(Multiply *p) = 0;
  virtual void visitDivide(Divide *p) = 0;
  virtual void visitLogicAnd(LogicAnd *p) = 0;
  virtual void visitRef(Ref *p) = 0;
  virtual void visitDeref(Deref *p) = 0;
  virtual void visitApplication(Application *p) = 0;
  virtual void visitDotRecord(DotRecord *p) = 0;
  virtual void visitDotTuple(DotTuple *p) = 0;
  virtual void visitTuple(Tuple *p) = 0;
  virtual void visitRecord(Record *p) = 0;
  virtual void visitPanic(Panic *p) = 0;
  virtual void visitInl(Inl *p) = 0;
  virtual void visitInr(Inr *p) = 0;
  virtual void visitSucc(Succ *p) = 0;
  virtual void visitLogicNot(LogicNot *p) = 0;
  virtual void visitPred(Pred *p) = 0;
  virtual void visitIsZero(IsZero *p) = 0;
  virtual void visitNatRec(NatRec *p) = 0;
  virtual void visitConstTrue(ConstTrue *p) = 0;
  virtual void visitConstFalse(ConstFalse *p) = 0;
  virtual void visitConstUnit(ConstUnit *p) = 0;
  virtual void visitConstInt(ConstInt *p) = 0;
  virtual void visitVar(Var *p) = 0;
  virtual void visitTypeFun(TypeFun *p) = 0;
  virtual void visitTypeSum(TypeSum *p) = 0;
  virtual void visitTypeTuple(TypeTuple *p) = 0;
  virtual void visitTypeRecord(TypeRecord *p) = 0;
  virtual void visitTypeBool(TypeBool *p) = 0;
  virtual void visitTypeNat(TypeNat *p) = 0;
  virtual void visitTypeUnit(TypeUnit *p) = 0;
  virtual void visitTypeTop(TypeTop *p) = 0;
  virtual void visitTypeBottom(TypeBottom *p) = 0;
  virtual void visitTypeRef(TypeRef *p) = 0;
  virtual void visitTypeVar(TypeVar *p) = 0;
  virtual void visitARecordFieldType(ARecordFieldType *p) = 0;
  virtual void visitListSaulIdent(ListSaulIdent *p) = 0;
  virtual void visitListDecl(ListDecl *p) = 0;
  virtual void visitListLocalDecl(ListLocalDecl *p) = 0;
  virtual void visitListAnnotation(ListAnnotation *p) = 0;
  virtual void visitListParamDecl(ListParamDecl *p) = 0;
  virtual void visitListType(ListType *p) = 0;
  virtual void visitListMatchCase(ListMatchCase *p) = 0;
  virtual void visitListPattern(ListPattern *p) = 0;
  virtual void visitListLabelledPattern(ListLabelledPattern *p) = 0;
  virtual void visitListBinding(ListBinding *p) = 0;
  virtual void visitListExpr(ListExpr *p) = 0;
  virtual void visitListRecordFieldType(ListRecordFieldType *p) = 0;


  virtual void visitInteger(Integer x) = 0;
  virtual void visitChar(Char x) = 0;
  virtual void visitDouble(Double x) = 0;
  virtual void visitString(String x) = 0;
  virtual void visitIdent(Ident x) = 0;
  virtual void visitSaulIdent(SaulIdent x) = 0;

};


class Visitable
{
 public:
  virtual ~Visitable() {}
  virtual void accept(Visitor *v) = 0;
};


/********************   Abstract Syntax Classes    ********************/

class Program : public Visitable
{
public:
  virtual Program *clone() const = 0;
  int line_number, char_number;
};

class LanguageDecl : public Visitable
{
public:
  virtual LanguageDecl *clone() const = 0;
  int line_number, char_number;
};

class Decl : public Visitable
{
public:
  virtual Decl *clone() const = 0;
  int line_number, char_number;
};

class LocalDecl : public Visitable
{
public:
  virtual LocalDecl *clone() const = 0;
  int line_number, char_number;
};

class Annotation : public Visitable
{
public:
  virtual Annotation *clone() const = 0;
  int line_number, char_number;
};

class ParamDecl : public Visitable
{
public:
  virtual ParamDecl *clone() const = 0;
  int line_number, char_number;
};

class ReturnType : public Visitable
{
public:
  virtual ReturnType *clone() const = 0;
  int line_number, char_number;
};

class Type : public Visitable
{
public:
  virtual Type *clone() const = 0;
  int line_number, char_number;
};

class MatchCase : public Visitable
{
public:
  virtual MatchCase *clone() const = 0;
  int line_number, char_number;
};

class Pattern : public Visitable
{
public:
  virtual Pattern *clone() const = 0;
  int line_number, char_number;
};

class LabelledPattern : public Visitable
{
public:
  virtual LabelledPattern *clone() const = 0;
  int line_number, char_number;
};

class Binding : public Visitable
{
public:
  virtual Binding *clone() const = 0;
  int line_number, char_number;
};

class Expr : public Visitable
{
public:
  virtual Expr *clone() const = 0;
  int line_number, char_number;
};

class RecordFieldType : public Visitable
{
public:
  virtual RecordFieldType *clone() const = 0;
  int line_number, char_number;
};



class AProgram : public Program
{
public:
  LanguageDecl *languagedecl_;
  ListDecl *listdecl_;

  AProgram(const AProgram &);
  AProgram &operator=(const AProgram &);
  AProgram(LanguageDecl *p1, ListDecl *p2);
  ~AProgram();
  virtual void accept(Visitor *v);
  virtual AProgram *clone() const;
  void swap(AProgram &);
};

class LanguageCore : public LanguageDecl
{
public:

  LanguageCore(const LanguageCore &);
  LanguageCore &operator=(const LanguageCore &);
  LanguageCore();
  ~LanguageCore();
  virtual void accept(Visitor *v);
  virtual LanguageCore *clone() const;
  void swap(LanguageCore &);
};

class DeclFun : public Decl
{
public:
  ListAnnotation *listannotation_;
  SaulIdent saulident_;
  ListParamDecl *listparamdecl_;
  ReturnType *returntype_;
  ListDecl *listdecl_;
  Expr *expr_;

  DeclFun(const DeclFun &);
  DeclFun &operator=(const DeclFun &);
  DeclFun(ListAnnotation *p1, SaulIdent p2, ListParamDecl *p3, ReturnType *p4, ListDecl *p5, Expr *p6);
  ~DeclFun();
  virtual void accept(Visitor *v);
  virtual DeclFun *clone() const;
  void swap(DeclFun &);
};

class ALocalDecl : public LocalDecl
{
public:
  Decl *decl_;

  ALocalDecl(const ALocalDecl &);
  ALocalDecl &operator=(const ALocalDecl &);
  ALocalDecl(Decl *p1);
  ~ALocalDecl();
  virtual void accept(Visitor *v);
  virtual ALocalDecl *clone() const;
  void swap(ALocalDecl &);
};

class InlineAnnotation : public Annotation
{
public:

  InlineAnnotation(const InlineAnnotation &);
  InlineAnnotation &operator=(const InlineAnnotation &);
  InlineAnnotation();
  ~InlineAnnotation();
  virtual void accept(Visitor *v);
  virtual InlineAnnotation *clone() const;
  void swap(InlineAnnotation &);
};

class AParamDecl : public ParamDecl
{
public:
  SaulIdent saulident_;
  Type *type_;

  AParamDecl(const AParamDecl &);
  AParamDecl &operator=(const AParamDecl &);
  AParamDecl(SaulIdent p1, Type *p2);
  ~AParamDecl();
  virtual void accept(Visitor *v);
  virtual AParamDecl *clone() const;
  void swap(AParamDecl &);
};

class NoReturnType : public ReturnType
{
public:

  NoReturnType(const NoReturnType &);
  NoReturnType &operator=(const NoReturnType &);
  NoReturnType();
  ~NoReturnType();
  virtual void accept(Visitor *v);
  virtual NoReturnType *clone() const;
  void swap(NoReturnType &);
};

class SomeReturnType : public ReturnType
{
public:
  Type *type_;

  SomeReturnType(const SomeReturnType &);
  SomeReturnType &operator=(const SomeReturnType &);
  SomeReturnType(Type *p1);
  ~SomeReturnType();
  virtual void accept(Visitor *v);
  virtual SomeReturnType *clone() const;
  void swap(SomeReturnType &);
};

class TypeFun : public Type
{
public:
  ListType *listtype_;
  Type *type_;

  TypeFun(const TypeFun &);
  TypeFun &operator=(const TypeFun &);
  TypeFun(ListType *p1, Type *p2);
  ~TypeFun();
  virtual void accept(Visitor *v);
  virtual TypeFun *clone() const;
  void swap(TypeFun &);
};

class TypeSum : public Type
{
public:
  Type *type_1;
  Type *type_2;

  TypeSum(const TypeSum &);
  TypeSum &operator=(const TypeSum &);
  TypeSum(Type *p1, Type *p2);
  ~TypeSum();
  virtual void accept(Visitor *v);
  virtual TypeSum *clone() const;
  void swap(TypeSum &);
};

class TypeTuple : public Type
{
public:
  ListType *listtype_;

  TypeTuple(const TypeTuple &);
  TypeTuple &operator=(const TypeTuple &);
  TypeTuple(ListType *p1);
  ~TypeTuple();
  virtual void accept(Visitor *v);
  virtual TypeTuple *clone() const;
  void swap(TypeTuple &);
};

class TypeRecord : public Type
{
public:
  ListRecordFieldType *listrecordfieldtype_;

  TypeRecord(const TypeRecord &);
  TypeRecord &operator=(const TypeRecord &);
  TypeRecord(ListRecordFieldType *p1);
  ~TypeRecord();
  virtual void accept(Visitor *v);
  virtual TypeRecord *clone() const;
  void swap(TypeRecord &);
};

class TypeBool : public Type
{
public:

  TypeBool(const TypeBool &);
  TypeBool &operator=(const TypeBool &);
  TypeBool();
  ~TypeBool();
  virtual void accept(Visitor *v);
  virtual TypeBool *clone() const;
  void swap(TypeBool &);
};

class TypeNat : public Type
{
public:

  TypeNat(const TypeNat &);
  TypeNat &operator=(const TypeNat &);
  TypeNat();
  ~TypeNat();
  virtual void accept(Visitor *v);
  virtual TypeNat *clone() const;
  void swap(TypeNat &);
};

class TypeUnit : public Type
{
public:

  TypeUnit(const TypeUnit &);
  TypeUnit &operator=(const TypeUnit &);
  TypeUnit();
  ~TypeUnit();
  virtual void accept(Visitor *v);
  virtual TypeUnit *clone() const;
  void swap(TypeUnit &);
};

class TypeTop : public Type
{
public:

  TypeTop(const TypeTop &);
  TypeTop &operator=(const TypeTop &);
  TypeTop();
  ~TypeTop();
  virtual void accept(Visitor *v);
  virtual TypeTop *clone() const;
  void swap(TypeTop &);
};

class TypeBottom : public Type
{
public:

  TypeBottom(const TypeBottom &);
  TypeBottom &operator=(const TypeBottom &);
  TypeBottom();
  ~TypeBottom();
  virtual void accept(Visitor *v);
  virtual TypeBottom *clone() const;
  void swap(TypeBottom &);
};

class TypeRef : public Type
{
public:
  Type *type_;

  TypeRef(const TypeRef &);
  TypeRef &operator=(const TypeRef &);
  TypeRef(Type *p1);
  ~TypeRef();
  virtual void accept(Visitor *v);
  virtual TypeRef *clone() const;
  void swap(TypeRef &);
};

class TypeVar : public Type
{
public:
  SaulIdent saulident_;

  TypeVar(const TypeVar &);
  TypeVar &operator=(const TypeVar &);
  TypeVar(SaulIdent p1);
  ~TypeVar();
  virtual void accept(Visitor *v);
  virtual TypeVar *clone() const;
  void swap(TypeVar &);
};

class AMatchCase : public MatchCase
{
public:
  Pattern *pattern_;
  Expr *expr_;

  AMatchCase(const AMatchCase &);
  AMatchCase &operator=(const AMatchCase &);
  AMatchCase(Pattern *p1, Expr *p2);
  ~AMatchCase();
  virtual void accept(Visitor *v);
  virtual AMatchCase *clone() const;
  void swap(AMatchCase &);
};

class PatternInl : public Pattern
{
public:
  Pattern *pattern_;

  PatternInl(const PatternInl &);
  PatternInl &operator=(const PatternInl &);
  PatternInl(Pattern *p1);
  ~PatternInl();
  virtual void accept(Visitor *v);
  virtual PatternInl *clone() const;
  void swap(PatternInl &);
};

class PatternInr : public Pattern
{
public:
  Pattern *pattern_;

  PatternInr(const PatternInr &);
  PatternInr &operator=(const PatternInr &);
  PatternInr(Pattern *p1);
  ~PatternInr();
  virtual void accept(Visitor *v);
  virtual PatternInr *clone() const;
  void swap(PatternInr &);
};

class PatternTuple : public Pattern
{
public:
  ListPattern *listpattern_;

  PatternTuple(const PatternTuple &);
  PatternTuple &operator=(const PatternTuple &);
  PatternTuple(ListPattern *p1);
  ~PatternTuple();
  virtual void accept(Visitor *v);
  virtual PatternTuple *clone() const;
  void swap(PatternTuple &);
};

class PatternRecord : public Pattern
{
public:
  ListLabelledPattern *listlabelledpattern_;

  PatternRecord(const PatternRecord &);
  PatternRecord &operator=(const PatternRecord &);
  PatternRecord(ListLabelledPattern *p1);
  ~PatternRecord();
  virtual void accept(Visitor *v);
  virtual PatternRecord *clone() const;
  void swap(PatternRecord &);
};

class PatternFalse : public Pattern
{
public:

  PatternFalse(const PatternFalse &);
  PatternFalse &operator=(const PatternFalse &);
  PatternFalse();
  ~PatternFalse();
  virtual void accept(Visitor *v);
  virtual PatternFalse *clone() const;
  void swap(PatternFalse &);
};

class PatternTrue : public Pattern
{
public:

  PatternTrue(const PatternTrue &);
  PatternTrue &operator=(const PatternTrue &);
  PatternTrue();
  ~PatternTrue();
  virtual void accept(Visitor *v);
  virtual PatternTrue *clone() const;
  void swap(PatternTrue &);
};

class PatternUnit : public Pattern
{
public:

  PatternUnit(const PatternUnit &);
  PatternUnit &operator=(const PatternUnit &);
  PatternUnit();
  ~PatternUnit();
  virtual void accept(Visitor *v);
  virtual PatternUnit *clone() const;
  void swap(PatternUnit &);
};

class PatternInt : public Pattern
{
public:
  Integer integer_;

  PatternInt(const PatternInt &);
  PatternInt &operator=(const PatternInt &);
  PatternInt(Integer p1);
  ~PatternInt();
  virtual void accept(Visitor *v);
  virtual PatternInt *clone() const;
  void swap(PatternInt &);
};

class PatternSucc : public Pattern
{
public:
  Pattern *pattern_;

  PatternSucc(const PatternSucc &);
  PatternSucc &operator=(const PatternSucc &);
  PatternSucc(Pattern *p1);
  ~PatternSucc();
  virtual void accept(Visitor *v);
  virtual PatternSucc *clone() const;
  void swap(PatternSucc &);
};

class PatternVar : public Pattern
{
public:
  SaulIdent saulident_;

  PatternVar(const PatternVar &);
  PatternVar &operator=(const PatternVar &);
  PatternVar(SaulIdent p1);
  ~PatternVar();
  virtual void accept(Visitor *v);
  virtual PatternVar *clone() const;
  void swap(PatternVar &);
};

class ALabelledPattern : public LabelledPattern
{
public:
  SaulIdent saulident_;
  Pattern *pattern_;

  ALabelledPattern(const ALabelledPattern &);
  ALabelledPattern &operator=(const ALabelledPattern &);
  ALabelledPattern(SaulIdent p1, Pattern *p2);
  ~ALabelledPattern();
  virtual void accept(Visitor *v);
  virtual ALabelledPattern *clone() const;
  void swap(ALabelledPattern &);
};

class ABinding : public Binding
{
public:
  SaulIdent saulident_;
  Expr *expr_;

  ABinding(const ABinding &);
  ABinding &operator=(const ABinding &);
  ABinding(SaulIdent p1, Expr *p2);
  ~ABinding();
  virtual void accept(Visitor *v);
  virtual ABinding *clone() const;
  void swap(ABinding &);
};

class Sequence : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Sequence(const Sequence &);
  Sequence &operator=(const Sequence &);
  Sequence(Expr *p1, Expr *p2);
  ~Sequence();
  virtual void accept(Visitor *v);
  virtual Sequence *clone() const;
  void swap(Sequence &);
};

class Assign : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Assign(const Assign &);
  Assign &operator=(const Assign &);
  Assign(Expr *p1, Expr *p2);
  ~Assign();
  virtual void accept(Visitor *v);
  virtual Assign *clone() const;
  void swap(Assign &);
};

class If : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;
  Expr *expr_3;

  If(const If &);
  If &operator=(const If &);
  If(Expr *p1, Expr *p2, Expr *p3);
  ~If();
  virtual void accept(Visitor *v);
  virtual If *clone() const;
  void swap(If &);
};

class LessThan : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LessThan(const LessThan &);
  LessThan &operator=(const LessThan &);
  LessThan(Expr *p1, Expr *p2);
  ~LessThan();
  virtual void accept(Visitor *v);
  virtual LessThan *clone() const;
  void swap(LessThan &);
};

class LessThanOrEqual : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LessThanOrEqual(const LessThanOrEqual &);
  LessThanOrEqual &operator=(const LessThanOrEqual &);
  LessThanOrEqual(Expr *p1, Expr *p2);
  ~LessThanOrEqual();
  virtual void accept(Visitor *v);
  virtual LessThanOrEqual *clone() const;
  void swap(LessThanOrEqual &);
};

class GreaterThan : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  GreaterThan(const GreaterThan &);
  GreaterThan &operator=(const GreaterThan &);
  GreaterThan(Expr *p1, Expr *p2);
  ~GreaterThan();
  virtual void accept(Visitor *v);
  virtual GreaterThan *clone() const;
  void swap(GreaterThan &);
};

class GreaterThanOrEqual : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  GreaterThanOrEqual(const GreaterThanOrEqual &);
  GreaterThanOrEqual &operator=(const GreaterThanOrEqual &);
  GreaterThanOrEqual(Expr *p1, Expr *p2);
  ~GreaterThanOrEqual();
  virtual void accept(Visitor *v);
  virtual GreaterThanOrEqual *clone() const;
  void swap(GreaterThanOrEqual &);
};

class Equal : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Equal(const Equal &);
  Equal &operator=(const Equal &);
  Equal(Expr *p1, Expr *p2);
  ~Equal();
  virtual void accept(Visitor *v);
  virtual Equal *clone() const;
  void swap(Equal &);
};

class NotEqual : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  NotEqual(const NotEqual &);
  NotEqual &operator=(const NotEqual &);
  NotEqual(Expr *p1, Expr *p2);
  ~NotEqual();
  virtual void accept(Visitor *v);
  virtual NotEqual *clone() const;
  void swap(NotEqual &);
};

class Abstraction : public Expr
{
public:
  ListParamDecl *listparamdecl_;
  Expr *expr_;

  Abstraction(const Abstraction &);
  Abstraction &operator=(const Abstraction &);
  Abstraction(ListParamDecl *p1, Expr *p2);
  ~Abstraction();
  virtual void accept(Visitor *v);
  virtual Abstraction *clone() const;
  void swap(Abstraction &);
};

class Match : public Expr
{
public:
  Expr *expr_;
  ListMatchCase *listmatchcase_;

  Match(const Match &);
  Match &operator=(const Match &);
  Match(Expr *p1, ListMatchCase *p2);
  ~Match();
  virtual void accept(Visitor *v);
  virtual Match *clone() const;
  void swap(Match &);
};

class Add : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Add(const Add &);
  Add &operator=(const Add &);
  Add(Expr *p1, Expr *p2);
  ~Add();
  virtual void accept(Visitor *v);
  virtual Add *clone() const;
  void swap(Add &);
};

class Subtract : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Subtract(const Subtract &);
  Subtract &operator=(const Subtract &);
  Subtract(Expr *p1, Expr *p2);
  ~Subtract();
  virtual void accept(Visitor *v);
  virtual Subtract *clone() const;
  void swap(Subtract &);
};

class LogicOr : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicOr(const LogicOr &);
  LogicOr &operator=(const LogicOr &);
  LogicOr(Expr *p1, Expr *p2);
  ~LogicOr();
  virtual void accept(Visitor *v);
  virtual LogicOr *clone() const;
  void swap(LogicOr &);
};

class Multiply : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Multiply(const Multiply &);
  Multiply &operator=(const Multiply &);
  Multiply(Expr *p1, Expr *p2);
  ~Multiply();
  virtual void accept(Visitor *v);
  virtual Multiply *clone() const;
  void swap(Multiply &);
};

class Divide : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  Divide(const Divide &);
  Divide &operator=(const Divide &);
  Divide(Expr *p1, Expr *p2);
  ~Divide();
  virtual void accept(Visitor *v);
  virtual Divide *clone() const;
  void swap(Divide &);
};

class LogicAnd : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;

  LogicAnd(const LogicAnd &);
  LogicAnd &operator=(const LogicAnd &);
  LogicAnd(Expr *p1, Expr *p2);
  ~LogicAnd();
  virtual void accept(Visitor *v);
  virtual LogicAnd *clone() const;
  void swap(LogicAnd &);
};

class Ref : public Expr
{
public:
  Expr *expr_;

  Ref(const Ref &);
  Ref &operator=(const Ref &);
  Ref(Expr *p1);
  ~Ref();
  virtual void accept(Visitor *v);
  virtual Ref *clone() const;
  void swap(Ref &);
};

class Deref : public Expr
{
public:
  Expr *expr_;

  Deref(const Deref &);
  Deref &operator=(const Deref &);
  Deref(Expr *p1);
  ~Deref();
  virtual void accept(Visitor *v);
  virtual Deref *clone() const;
  void swap(Deref &);
};

class Application : public Expr
{
public:
  Expr *expr_;
  ListExpr *listexpr_;

  Application(const Application &);
  Application &operator=(const Application &);
  Application(Expr *p1, ListExpr *p2);
  ~Application();
  virtual void accept(Visitor *v);
  virtual Application *clone() const;
  void swap(Application &);
};

class DotRecord : public Expr
{
public:
  Expr *expr_;
  SaulIdent saulident_;

  DotRecord(const DotRecord &);
  DotRecord &operator=(const DotRecord &);
  DotRecord(Expr *p1, SaulIdent p2);
  ~DotRecord();
  virtual void accept(Visitor *v);
  virtual DotRecord *clone() const;
  void swap(DotRecord &);
};

class DotTuple : public Expr
{
public:
  Expr *expr_;
  Integer integer_;

  DotTuple(const DotTuple &);
  DotTuple &operator=(const DotTuple &);
  DotTuple(Expr *p1, Integer p2);
  ~DotTuple();
  virtual void accept(Visitor *v);
  virtual DotTuple *clone() const;
  void swap(DotTuple &);
};

class Tuple : public Expr
{
public:
  ListExpr *listexpr_;

  Tuple(const Tuple &);
  Tuple &operator=(const Tuple &);
  Tuple(ListExpr *p1);
  ~Tuple();
  virtual void accept(Visitor *v);
  virtual Tuple *clone() const;
  void swap(Tuple &);
};

class Record : public Expr
{
public:
  ListBinding *listbinding_;

  Record(const Record &);
  Record &operator=(const Record &);
  Record(ListBinding *p1);
  ~Record();
  virtual void accept(Visitor *v);
  virtual Record *clone() const;
  void swap(Record &);
};

class Panic : public Expr
{
public:

  Panic(const Panic &);
  Panic &operator=(const Panic &);
  Panic();
  ~Panic();
  virtual void accept(Visitor *v);
  virtual Panic *clone() const;
  void swap(Panic &);
};

class Inl : public Expr
{
public:
  Expr *expr_;

  Inl(const Inl &);
  Inl &operator=(const Inl &);
  Inl(Expr *p1);
  ~Inl();
  virtual void accept(Visitor *v);
  virtual Inl *clone() const;
  void swap(Inl &);
};

class Inr : public Expr
{
public:
  Expr *expr_;

  Inr(const Inr &);
  Inr &operator=(const Inr &);
  Inr(Expr *p1);
  ~Inr();
  virtual void accept(Visitor *v);
  virtual Inr *clone() const;
  void swap(Inr &);
};

class Succ : public Expr
{
public:
  Expr *expr_;

  Succ(const Succ &);
  Succ &operator=(const Succ &);
  Succ(Expr *p1);
  ~Succ();
  virtual void accept(Visitor *v);
  virtual Succ *clone() const;
  void swap(Succ &);
};

class LogicNot : public Expr
{
public:
  Expr *expr_;

  LogicNot(const LogicNot &);
  LogicNot &operator=(const LogicNot &);
  LogicNot(Expr *p1);
  ~LogicNot();
  virtual void accept(Visitor *v);
  virtual LogicNot *clone() const;
  void swap(LogicNot &);
};

class Pred : public Expr
{
public:
  Expr *expr_;

  Pred(const Pred &);
  Pred &operator=(const Pred &);
  Pred(Expr *p1);
  ~Pred();
  virtual void accept(Visitor *v);
  virtual Pred *clone() const;
  void swap(Pred &);
};

class IsZero : public Expr
{
public:
  Expr *expr_;

  IsZero(const IsZero &);
  IsZero &operator=(const IsZero &);
  IsZero(Expr *p1);
  ~IsZero();
  virtual void accept(Visitor *v);
  virtual IsZero *clone() const;
  void swap(IsZero &);
};

class NatRec : public Expr
{
public:
  Expr *expr_1;
  Expr *expr_2;
  Expr *expr_3;

  NatRec(const NatRec &);
  NatRec &operator=(const NatRec &);
  NatRec(Expr *p1, Expr *p2, Expr *p3);
  ~NatRec();
  virtual void accept(Visitor *v);
  virtual NatRec *clone() const;
  void swap(NatRec &);
};

class ConstTrue : public Expr
{
public:

  ConstTrue(const ConstTrue &);
  ConstTrue &operator=(const ConstTrue &);
  ConstTrue();
  ~ConstTrue();
  virtual void accept(Visitor *v);
  virtual ConstTrue *clone() const;
  void swap(ConstTrue &);
};

class ConstFalse : public Expr
{
public:

  ConstFalse(const ConstFalse &);
  ConstFalse &operator=(const ConstFalse &);
  ConstFalse();
  ~ConstFalse();
  virtual void accept(Visitor *v);
  virtual ConstFalse *clone() const;
  void swap(ConstFalse &);
};

class ConstUnit : public Expr
{
public:

  ConstUnit(const ConstUnit &);
  ConstUnit &operator=(const ConstUnit &);
  ConstUnit();
  ~ConstUnit();
  virtual void accept(Visitor *v);
  virtual ConstUnit *clone() const;
  void swap(ConstUnit &);
};

class ConstInt : public Expr
{
public:
  Integer integer_;

  ConstInt(const ConstInt &);
  ConstInt &operator=(const ConstInt &);
  ConstInt(Integer p1);
  ~ConstInt();
  virtual void accept(Visitor *v);
  virtual ConstInt *clone() const;
  void swap(ConstInt &);
};

class Var : public Expr
{
public:
  SaulIdent saulident_;

  Var(const Var &);
  Var &operator=(const Var &);
  Var(SaulIdent p1);
  ~Var();
  virtual void accept(Visitor *v);
  virtual Var *clone() const;
  void swap(Var &);
};

class ARecordFieldType : public RecordFieldType
{
public:
  SaulIdent saulident_;
  Type *type_;

  ARecordFieldType(const ARecordFieldType &);
  ARecordFieldType &operator=(const ARecordFieldType &);
  ARecordFieldType(SaulIdent p1, Type *p2);
  ~ARecordFieldType();
  virtual void accept(Visitor *v);
  virtual ARecordFieldType *clone() const;
  void swap(ARecordFieldType &);
};



class ListSaulIdent : public Visitable, public std::vector<SaulIdent>
{
public:
  virtual void accept(Visitor *v);
  virtual ListSaulIdent *clone() const;
};

ListSaulIdent* consListSaulIdent(SaulIdent x, ListSaulIdent* xs);

class ListDecl : public Visitable, public std::vector<Decl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListDecl *clone() const;
};

ListDecl* consListDecl(Decl* x, ListDecl* xs);

class ListLocalDecl : public Visitable, public std::vector<LocalDecl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLocalDecl *clone() const;
};

ListLocalDecl* consListLocalDecl(LocalDecl* x, ListLocalDecl* xs);

class ListAnnotation : public Visitable, public std::vector<Annotation*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListAnnotation *clone() const;
};

ListAnnotation* consListAnnotation(Annotation* x, ListAnnotation* xs);

class ListParamDecl : public Visitable, public std::vector<ParamDecl*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListParamDecl *clone() const;
};

ListParamDecl* consListParamDecl(ParamDecl* x, ListParamDecl* xs);

class ListType : public Visitable, public std::vector<Type*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListType *clone() const;
};

ListType* consListType(Type* x, ListType* xs);

class ListMatchCase : public Visitable, public std::vector<MatchCase*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListMatchCase *clone() const;
};

ListMatchCase* consListMatchCase(MatchCase* x, ListMatchCase* xs);

class ListPattern : public Visitable, public std::vector<Pattern*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListPattern *clone() const;
};

ListPattern* consListPattern(Pattern* x, ListPattern* xs);

class ListLabelledPattern : public Visitable, public std::vector<LabelledPattern*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListLabelledPattern *clone() const;
};

ListLabelledPattern* consListLabelledPattern(LabelledPattern* x, ListLabelledPattern* xs);

class ListBinding : public Visitable, public std::vector<Binding*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListBinding *clone() const;
};

ListBinding* consListBinding(Binding* x, ListBinding* xs);

class ListExpr : public Visitable, public std::vector<Expr*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListExpr *clone() const;
};

ListExpr* consListExpr(Expr* x, ListExpr* xs);

class ListRecordFieldType : public Visitable, public std::vector<RecordFieldType*>
{
public:
  virtual void accept(Visitor *v);
  virtual ListRecordFieldType *clone() const;
};

ListRecordFieldType* consListRecordFieldType(RecordFieldType* x, ListRecordFieldType* xs);




}
#endif
