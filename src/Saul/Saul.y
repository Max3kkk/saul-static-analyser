/* -*- c++ -*- File generated by the BNF Converter (bnfc 2.9.4.1). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.H"
%name-prefix = "Saul"
  /* From Bison 2.6: %define api.prefix {Saul} */

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the Saullloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <algorithm> /* for std::reverse */
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.H"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE Saul_scan_string(const char *str, yyscan_t scanner);
extern void Saul_delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void Saullex_destroy(yyscan_t scanner);
extern char* Saulget_text(yyscan_t scanner);

extern yyscan_t Saul_initialize_lexer(FILE * inp);

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  Saul::Program* program_;
  Saul::ListSaulIdent* listsaulident_;
  Saul::LanguageDecl* languagedecl_;
  Saul::Decl* decl_;
  Saul::ListDecl* listdecl_;
  Saul::LocalDecl* localdecl_;
  Saul::ListLocalDecl* listlocaldecl_;
  Saul::Annotation* annotation_;
  Saul::ListAnnotation* listannotation_;
  Saul::ParamDecl* paramdecl_;
  Saul::ListParamDecl* listparamdecl_;
  Saul::ReturnType* returntype_;
  Saul::Type* type_;
  Saul::ListType* listtype_;
  Saul::MatchCase* matchcase_;
  Saul::ListMatchCase* listmatchcase_;
  Saul::Pattern* pattern_;
  Saul::ListPattern* listpattern_;
  Saul::LabelledPattern* labelledpattern_;
  Saul::ListLabelledPattern* listlabelledpattern_;
  Saul::Binding* binding_;
  Saul::ListBinding* listbinding_;
  Saul::Expr* expr_;
  Saul::ListExpr* listexpr_;
  Saul::RecordFieldType* recordfieldtype_;
  Saul::ListRecordFieldType* listrecordfieldtype_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, Saulget_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _BANGEQ       /* != */
%token          _AMP          /* & */
%token          _LPAREN       /* ( */
%token          _RPAREN       /* ) */
%token          _STAR         /* * */
%token          _PLUS         /* + */
%token          _COMMA        /* , */
%token          _MINUS        /* - */
%token          _RARROW       /* -> */
%token          _DOT          /* . */
%token          _SLASH        /* / */
%token          _COLON        /* : */
%token          _COLONEQ      /* := */
%token          _SEMI         /* ; */
%token          _LT           /* < */
%token          _LDARROW      /* <= */
%token          _EQ           /* = */
%token          _DEQ          /* == */
%token          _RDARROW      /* => */
%token          _GT           /* > */
%token          _GTEQ         /* >= */
%token          _KW_Bool      /* Bool */
%token          _KW_Bot       /* Bot */
%token          _KW_Nat       /* Nat */
%token          _SYMB_25      /* Nat::iszero */
%token          _SYMB_24      /* Nat::pred */
%token          _SYMB_26      /* Nat::rec */
%token          _KW_Top       /* Top */
%token          _KW_Unit      /* Unit */
%token          _KW_and       /* and */
%token          _KW_core      /* core */
%token          _KW_else      /* else */
%token          _KW_false     /* false */
%token          _KW_fn        /* fn */
%token          _KW_if        /* if */
%token          _KW_inl       /* inl */
%token          _KW_inline    /* inline */
%token          _KW_inr       /* inr */
%token          _KW_language  /* language */
%token          _KW_match     /* match */
%token          _KW_new       /* new */
%token          _KW_not       /* not */
%token          _KW_or        /* or */
%token          _SYMB_23      /* panic! */
%token          _KW_return    /* return */
%token          _KW_succ      /* succ */
%token          _KW_then      /* then */
%token          _KW_true      /* true */
%token          _KW_unit      /* unit */
%token          _LBRACE       /* { */
%token          _BAR          /* | */
%token          _RBRACE       /* } */
%token<_string> T_SaulIdent   /* SaulIdent */
%token<_int>    _INTEGER_

%type <program_> Program
%type <listsaulident_> ListSaulIdent
%type <languagedecl_> LanguageDecl
%type <decl_> Decl
%type <listdecl_> ListDecl
%type <localdecl_> LocalDecl
%type <listlocaldecl_> ListLocalDecl
%type <annotation_> Annotation
%type <listannotation_> ListAnnotation
%type <paramdecl_> ParamDecl
%type <listparamdecl_> ListParamDecl
%type <returntype_> ReturnType
%type <type_> Type9
%type <listtype_> ListType9
%type <matchcase_> MatchCase
%type <listmatchcase_> ListMatchCase
%type <pattern_> Pattern
%type <listpattern_> ListPattern
%type <labelledpattern_> LabelledPattern
%type <listlabelledpattern_> ListLabelledPattern
%type <binding_> Binding
%type <listbinding_> ListBinding
%type <expr_> Expr
%type <listexpr_> ListExpr
%type <expr_> Expr1
%type <expr_> Expr2
%type <listexpr_> ListExpr2
%type <expr_> Expr3
%type <expr_> Expr4
%type <expr_> Expr5
%type <expr_> Expr6
%type <expr_> Expr7
%type <type_> Type
%type <type_> Type1
%type <type_> Type2
%type <type_> Type3
%type <listtype_> ListType
%type <recordfieldtype_> RecordFieldType
%type <listrecordfieldtype_> ListRecordFieldType

%start Program

%%

Program : LanguageDecl ListDecl { $$ = new Saul::AProgram($1, $2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->program_ = $$; }
;
ListSaulIdent : /* empty */ { $$ = new Saul::ListSaulIdent(); result->listsaulident_ = $$; }
  | T_SaulIdent { $$ = new Saul::ListSaulIdent(); $$->push_back($1); result->listsaulident_ = $$; }
  | T_SaulIdent _COMMA ListSaulIdent { $3->push_back($1); $$ = $3; result->listsaulident_ = $$; }
;
LanguageDecl : _KW_language _KW_core _SEMI { $$ = new Saul::LanguageCore(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->languagedecl_ = $$; }
;
Decl : ListAnnotation _KW_fn T_SaulIdent _LPAREN ListParamDecl _RPAREN ReturnType _LBRACE ListDecl _KW_return Expr _RBRACE { std::reverse($5->begin(),$5->end()) ;$$ = new Saul::DeclFun($1, $3, $5, $7, $9, $11); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->decl_ = $$; }
;
ListDecl : /* empty */ { $$ = new Saul::ListDecl(); result->listdecl_ = $$; }
  | ListDecl Decl { $1->push_back($2); $$ = $1; result->listdecl_ = $$; }
;
LocalDecl : Decl { $$ = new Saul::ALocalDecl($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->localdecl_ = $$; }
;
ListLocalDecl : /* empty */ { $$ = new Saul::ListLocalDecl(); result->listlocaldecl_ = $$; }
  | ListLocalDecl LocalDecl _SEMI { $1->push_back($2); $$ = $1; result->listlocaldecl_ = $$; }
;
Annotation : _KW_inline { $$ = new Saul::InlineAnnotation(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->annotation_ = $$; }
;
ListAnnotation : /* empty */ { $$ = new Saul::ListAnnotation(); result->listannotation_ = $$; }
  | ListAnnotation Annotation { $1->push_back($2); $$ = $1; result->listannotation_ = $$; }
;
ParamDecl : T_SaulIdent _COLON Type { $$ = new Saul::AParamDecl($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->paramdecl_ = $$; }
;
ListParamDecl : /* empty */ { $$ = new Saul::ListParamDecl(); result->listparamdecl_ = $$; }
  | ParamDecl { $$ = new Saul::ListParamDecl(); $$->push_back($1); result->listparamdecl_ = $$; }
  | ParamDecl _COMMA ListParamDecl { $3->push_back($1); $$ = $3; result->listparamdecl_ = $$; }
;
ReturnType : /* empty */ { $$ = new Saul::NoReturnType(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->returntype_ = $$; }
  | _RARROW Type { $$ = new Saul::SomeReturnType($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->returntype_ = $$; }
;
Type9 : Type { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
;
ListType9 : Type9 { $$ = new Saul::ListType(); $$->push_back($1); result->listtype_ = $$; }
  | Type9 _COMMA ListType9 { $3->push_back($1); $$ = $3; result->listtype_ = $$; }
;
MatchCase : Pattern _RDARROW Expr { $$ = new Saul::AMatchCase($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->matchcase_ = $$; }
;
ListMatchCase : /* empty */ { $$ = new Saul::ListMatchCase(); result->listmatchcase_ = $$; }
  | MatchCase { $$ = new Saul::ListMatchCase(); $$->push_back($1); result->listmatchcase_ = $$; }
  | MatchCase _BAR ListMatchCase { $3->push_back($1); $$ = $3; result->listmatchcase_ = $$; }
;
Pattern : _KW_inl _LPAREN Pattern _RPAREN { $$ = new Saul::PatternInl($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _KW_inr _LPAREN Pattern _RPAREN { $$ = new Saul::PatternInr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _LBRACE ListPattern _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new Saul::PatternTuple($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _LBRACE ListLabelledPattern _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new Saul::PatternRecord($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _KW_false { $$ = new Saul::PatternFalse(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _KW_true { $$ = new Saul::PatternTrue(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _KW_unit { $$ = new Saul::PatternUnit(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _INTEGER_ { $$ = new Saul::PatternInt($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _KW_succ _LPAREN Pattern _RPAREN { $$ = new Saul::PatternSucc($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | T_SaulIdent { $$ = new Saul::PatternVar($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
  | _LPAREN Pattern _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->pattern_ = $$; }
;
ListPattern : /* empty */ { $$ = new Saul::ListPattern(); result->listpattern_ = $$; }
  | Pattern { $$ = new Saul::ListPattern(); $$->push_back($1); result->listpattern_ = $$; }
  | Pattern _COMMA ListPattern { $3->push_back($1); $$ = $3; result->listpattern_ = $$; }
;
LabelledPattern : T_SaulIdent _EQ Pattern { $$ = new Saul::ALabelledPattern($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->labelledpattern_ = $$; }
;
ListLabelledPattern : LabelledPattern { $$ = new Saul::ListLabelledPattern(); $$->push_back($1); result->listlabelledpattern_ = $$; }
  | LabelledPattern _COMMA ListLabelledPattern { $3->push_back($1); $$ = $3; result->listlabelledpattern_ = $$; }
;
Binding : T_SaulIdent _EQ Expr { $$ = new Saul::ABinding($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->binding_ = $$; }
;
ListBinding : Binding { $$ = new Saul::ListBinding(); $$->push_back($1); result->listbinding_ = $$; }
  | Binding _COMMA ListBinding { $3->push_back($1); $$ = $3; result->listbinding_ = $$; }
;
Expr : Expr1 _SEMI Expr { $$ = new Saul::Sequence($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr1 _SEMI { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
ListExpr : /* empty */ { $$ = new Saul::ListExpr(); result->listexpr_ = $$; }
  | Expr { $$ = new Saul::ListExpr(); $$->push_back($1); result->listexpr_ = $$; }
  | Expr _COMMA ListExpr { $3->push_back($1); $$ = $3; result->listexpr_ = $$; }
;
Expr1 : Expr2 _COLONEQ Expr1 { $$ = new Saul::Assign($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_if Expr1 _KW_then Expr1 _KW_else Expr1 { $$ = new Saul::If($2, $4, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr2 : Expr3 _LT Expr3 { $$ = new Saul::LessThan($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _LDARROW Expr3 { $$ = new Saul::LessThanOrEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _GT Expr3 { $$ = new Saul::GreaterThan($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _GTEQ Expr3 { $$ = new Saul::GreaterThanOrEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _DEQ Expr3 { $$ = new Saul::Equal($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _BANGEQ Expr3 { $$ = new Saul::NotEqual($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
ListExpr2 : Expr2 _SEMI { $$ = new Saul::ListExpr(); $$->push_back($1); result->listexpr_ = $$; }
  | Expr2 _SEMI ListExpr2 { $3->push_back($1); $$ = $3; result->listexpr_ = $$; }
;
Expr3 : _KW_fn _LPAREN ListParamDecl _RPAREN _LBRACE _KW_return Expr _RBRACE { std::reverse($3->begin(),$3->end()) ;$$ = new Saul::Abstraction($3, $7); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_match Expr2 _LBRACE ListMatchCase _RBRACE { std::reverse($4->begin(),$4->end()) ;$$ = new Saul::Match($2, $4); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _PLUS Expr4 { $$ = new Saul::Add($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _MINUS Expr4 { $$ = new Saul::Subtract($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr3 _KW_or Expr4 { $$ = new Saul::LogicOr($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr4 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr4 : Expr4 _STAR Expr5 { $$ = new Saul::Multiply($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr4 _SLASH Expr5 { $$ = new Saul::Divide($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr4 _KW_and Expr5 { $$ = new Saul::LogicAnd($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr5 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr5 : _KW_new _LPAREN Expr5 _RPAREN { $$ = new Saul::Ref($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _STAR Expr5 { $$ = new Saul::Deref($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr6 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr6 : Expr6 _LPAREN ListExpr _RPAREN { std::reverse($3->begin(),$3->end()) ;$$ = new Saul::Application($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr6 _DOT T_SaulIdent { $$ = new Saul::DotRecord($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr6 _DOT _INTEGER_ { $$ = new Saul::DotTuple($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _LBRACE ListExpr _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new Saul::Tuple($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _LBRACE ListBinding _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new Saul::Record($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _SYMB_23 { $$ = new Saul::Panic(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_inl _LPAREN Expr _RPAREN { $$ = new Saul::Inl($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_inr _LPAREN Expr _RPAREN { $$ = new Saul::Inr($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_succ _LPAREN Expr _RPAREN { $$ = new Saul::Succ($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_not _LPAREN Expr _RPAREN { $$ = new Saul::LogicNot($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _SYMB_24 _LPAREN Expr _RPAREN { $$ = new Saul::Pred($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _SYMB_25 _LPAREN Expr _RPAREN { $$ = new Saul::IsZero($3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _SYMB_26 _LPAREN Expr _COMMA Expr _COMMA Expr _RPAREN { $$ = new Saul::NatRec($3, $5, $7); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | Expr7 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Expr7 : _KW_true { $$ = new Saul::ConstTrue(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_false { $$ = new Saul::ConstFalse(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _KW_unit { $$ = new Saul::ConstUnit(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _INTEGER_ { $$ = new Saul::ConstInt($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | T_SaulIdent { $$ = new Saul::Var($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
  | _LPAREN Expr _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->expr_ = $$; }
;
Type : _KW_fn _LPAREN ListType _RPAREN _RARROW Type { std::reverse($3->begin(),$3->end()) ;$$ = new Saul::TypeFun($3, $6); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | Type1 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
;
Type1 : Type2 _PLUS Type2 { $$ = new Saul::TypeSum($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | Type2 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
;
Type2 : _LBRACE ListType _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new Saul::TypeTuple($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | _LBRACE ListRecordFieldType _RBRACE { std::reverse($2->begin(),$2->end()) ;$$ = new Saul::TypeRecord($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | Type3 { $$ = $1; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
;
Type3 : _KW_Bool { $$ = new Saul::TypeBool(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | _KW_Nat { $$ = new Saul::TypeNat(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | _KW_Unit { $$ = new Saul::TypeUnit(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | _KW_Top { $$ = new Saul::TypeTop(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | _KW_Bot { $$ = new Saul::TypeBottom(); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | _AMP Type2 { $$ = new Saul::TypeRef($2); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | T_SaulIdent { $$ = new Saul::TypeVar($1); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
  | _LPAREN Type _RPAREN { $$ = $2; $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->type_ = $$; }
;
ListType : /* empty */ { $$ = new Saul::ListType(); result->listtype_ = $$; }
  | Type { $$ = new Saul::ListType(); $$->push_back($1); result->listtype_ = $$; }
  | Type _COMMA ListType { $3->push_back($1); $$ = $3; result->listtype_ = $$; }
;
RecordFieldType : T_SaulIdent _COLON Type { $$ = new Saul::ARecordFieldType($1, $3); $$->line_number = @$.first_line; $$->char_number = @$.first_column; result->recordfieldtype_ = $$; }
;
ListRecordFieldType : RecordFieldType { $$ = new Saul::ListRecordFieldType(); $$->push_back($1); result->listrecordfieldtype_ = $$; }
  | RecordFieldType _COMMA ListRecordFieldType { $3->push_back($1); $$ = $3; result->listrecordfieldtype_ = $$; }
;

%%

namespace Saul
{
/* Entrypoint: parse Program* from file. */
Program* pProgram(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse Program* from string. */
Program* psProgram(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.program_;
  }
}

/* Entrypoint: parse ListSaulIdent* from file. */
ListSaulIdent* pListSaulIdent(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listsaulident_->begin(), result.listsaulident_->end());
    return result.listsaulident_;
  }
}

/* Entrypoint: parse ListSaulIdent* from string. */
ListSaulIdent* psListSaulIdent(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listsaulident_->begin(), result.listsaulident_->end());
    return result.listsaulident_;
  }
}

/* Entrypoint: parse LanguageDecl* from file. */
LanguageDecl* pLanguageDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.languagedecl_;
  }
}

/* Entrypoint: parse LanguageDecl* from string. */
LanguageDecl* psLanguageDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.languagedecl_;
  }
}

/* Entrypoint: parse Decl* from file. */
Decl* pDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decl_;
  }
}

/* Entrypoint: parse Decl* from string. */
Decl* psDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.decl_;
  }
}

/* Entrypoint: parse ListDecl* from file. */
ListDecl* pListDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdecl_;
  }
}

/* Entrypoint: parse ListDecl* from string. */
ListDecl* psListDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listdecl_;
  }
}

/* Entrypoint: parse LocalDecl* from file. */
LocalDecl* pLocalDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.localdecl_;
  }
}

/* Entrypoint: parse LocalDecl* from string. */
LocalDecl* psLocalDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.localdecl_;
  }
}

/* Entrypoint: parse ListLocalDecl* from file. */
ListLocalDecl* pListLocalDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlocaldecl_;
  }
}

/* Entrypoint: parse ListLocalDecl* from string. */
ListLocalDecl* psListLocalDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listlocaldecl_;
  }
}

/* Entrypoint: parse Annotation* from file. */
Annotation* pAnnotation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotation_;
  }
}

/* Entrypoint: parse Annotation* from string. */
Annotation* psAnnotation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.annotation_;
  }
}

/* Entrypoint: parse ListAnnotation* from file. */
ListAnnotation* pListAnnotation(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listannotation_;
  }
}

/* Entrypoint: parse ListAnnotation* from string. */
ListAnnotation* psListAnnotation(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.listannotation_;
  }
}

/* Entrypoint: parse ParamDecl* from file. */
ParamDecl* pParamDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.paramdecl_;
  }
}

/* Entrypoint: parse ParamDecl* from string. */
ParamDecl* psParamDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.paramdecl_;
  }
}

/* Entrypoint: parse ListParamDecl* from file. */
ListParamDecl* pListParamDecl(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparamdecl_->begin(), result.listparamdecl_->end());
    return result.listparamdecl_;
  }
}

/* Entrypoint: parse ListParamDecl* from string. */
ListParamDecl* psListParamDecl(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listparamdecl_->begin(), result.listparamdecl_->end());
    return result.listparamdecl_;
  }
}

/* Entrypoint: parse ReturnType* from file. */
ReturnType* pReturnType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.returntype_;
  }
}

/* Entrypoint: parse ReturnType* from string. */
ReturnType* psReturnType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.returntype_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse ListType* from file. */
ListType* pListType9(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse ListType* from string. */
ListType* psListType9(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse MatchCase* from file. */
MatchCase* pMatchCase(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.matchcase_;
  }
}

/* Entrypoint: parse MatchCase* from string. */
MatchCase* psMatchCase(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.matchcase_;
  }
}

/* Entrypoint: parse ListMatchCase* from file. */
ListMatchCase* pListMatchCase(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listmatchcase_->begin(), result.listmatchcase_->end());
    return result.listmatchcase_;
  }
}

/* Entrypoint: parse ListMatchCase* from string. */
ListMatchCase* psListMatchCase(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listmatchcase_->begin(), result.listmatchcase_->end());
    return result.listmatchcase_;
  }
}

/* Entrypoint: parse Pattern* from file. */
Pattern* pPattern(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pattern_;
  }
}

/* Entrypoint: parse Pattern* from string. */
Pattern* psPattern(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.pattern_;
  }
}

/* Entrypoint: parse ListPattern* from file. */
ListPattern* pListPattern(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listpattern_->begin(), result.listpattern_->end());
    return result.listpattern_;
  }
}

/* Entrypoint: parse ListPattern* from string. */
ListPattern* psListPattern(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listpattern_->begin(), result.listpattern_->end());
    return result.listpattern_;
  }
}

/* Entrypoint: parse LabelledPattern* from file. */
LabelledPattern* pLabelledPattern(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.labelledpattern_;
  }
}

/* Entrypoint: parse LabelledPattern* from string. */
LabelledPattern* psLabelledPattern(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.labelledpattern_;
  }
}

/* Entrypoint: parse ListLabelledPattern* from file. */
ListLabelledPattern* pListLabelledPattern(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlabelledpattern_->begin(), result.listlabelledpattern_->end());
    return result.listlabelledpattern_;
  }
}

/* Entrypoint: parse ListLabelledPattern* from string. */
ListLabelledPattern* psListLabelledPattern(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listlabelledpattern_->begin(), result.listlabelledpattern_->end());
    return result.listlabelledpattern_;
  }
}

/* Entrypoint: parse Binding* from file. */
Binding* pBinding(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.binding_;
  }
}

/* Entrypoint: parse Binding* from string. */
Binding* psBinding(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.binding_;
  }
}

/* Entrypoint: parse ListBinding* from file. */
ListBinding* pListBinding(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbinding_->begin(), result.listbinding_->end());
    return result.listbinding_;
  }
}

/* Entrypoint: parse ListBinding* from string. */
ListBinding* psListBinding(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listbinding_->begin(), result.listbinding_->end());
    return result.listbinding_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse ListExpr* from file. */
ListExpr* pListExpr(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpr_->begin(), result.listexpr_->end());
    return result.listexpr_;
  }
}

/* Entrypoint: parse ListExpr* from string. */
ListExpr* psListExpr(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpr_->begin(), result.listexpr_->end());
    return result.listexpr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse ListExpr* from file. */
ListExpr* pListExpr2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpr_->begin(), result.listexpr_->end());
    return result.listexpr_;
  }
}

/* Entrypoint: parse ListExpr* from string. */
ListExpr* psListExpr2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listexpr_->begin(), result.listexpr_->end());
    return result.listexpr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr4(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr4(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr5(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr5(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr6(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr6(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from file. */
Expr* pExpr7(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Expr* from string. */
Expr* psExpr7(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.expr_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType1(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType1(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType2(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType2(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from file. */
Type* pType3(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse Type* from string. */
Type* psType3(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.type_;
  }
}

/* Entrypoint: parse ListType* from file. */
ListType* pListType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse ListType* from string. */
ListType* psListType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listtype_->begin(), result.listtype_->end());
    return result.listtype_;
  }
}

/* Entrypoint: parse RecordFieldType* from file. */
RecordFieldType* pRecordFieldType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.recordfieldtype_;
  }
}

/* Entrypoint: parse RecordFieldType* from string. */
RecordFieldType* psRecordFieldType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.recordfieldtype_;
  }
}

/* Entrypoint: parse ListRecordFieldType* from file. */
ListRecordFieldType* pListRecordFieldType(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listrecordfieldtype_->begin(), result.listrecordfieldtype_->end());
    return result.listrecordfieldtype_;
  }
}

/* Entrypoint: parse ListRecordFieldType* from string. */
ListRecordFieldType* psListRecordFieldType(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = Saul_initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = Saul_scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  Saul_delete_buffer(buf, scanner);
  Saullex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
std::reverse(result.listrecordfieldtype_->begin(), result.listrecordfieldtype_->end());
    return result.listrecordfieldtype_;
  }
}


}
