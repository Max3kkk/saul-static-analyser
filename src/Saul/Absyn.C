/* File generated by the BNF Converter (bnfc 2.9.4.1). */

//C++ Abstract Syntax Implementation.
#include <algorithm>
#include <string>
#include <vector>
#include "Absyn.H"
namespace Saul
{
/********************   AProgram    ********************/
AProgram::AProgram(LanguageDecl *p1, ListDecl *p2)
{
  languagedecl_ = p1;
  listdecl_ = p2;

}

AProgram::AProgram(const AProgram & other)
{
  languagedecl_ = other.languagedecl_->clone();
  listdecl_ = other.listdecl_->clone();

}

AProgram &AProgram::operator=(const AProgram & other)
{
  AProgram tmp(other);
  swap(tmp);
  return *this;
}

void AProgram::swap(AProgram & other)
{
  std::swap(languagedecl_, other.languagedecl_);
  std::swap(listdecl_, other.listdecl_);

}

AProgram::~AProgram()
{
  delete(languagedecl_);
  delete(listdecl_);

}

void AProgram::accept(Visitor *v)
{
  v->visitAProgram(this);
}

AProgram *AProgram::clone() const
{
  return new AProgram(*this);
}



/********************   LanguageCore    ********************/
LanguageCore::LanguageCore()
{

}

LanguageCore::LanguageCore(const LanguageCore & other)
{

}

LanguageCore &LanguageCore::operator=(const LanguageCore & other)
{
  LanguageCore tmp(other);
  swap(tmp);
  return *this;
}

void LanguageCore::swap(LanguageCore & other)
{

}

LanguageCore::~LanguageCore()
{

}

void LanguageCore::accept(Visitor *v)
{
  v->visitLanguageCore(this);
}

LanguageCore *LanguageCore::clone() const
{
  return new LanguageCore(*this);
}



/********************   DeclFun    ********************/
DeclFun::DeclFun(ListAnnotation *p1, SaulIdent p2, ListParamDecl *p3, ReturnType *p4, ListDecl *p5, Expr *p6)
{
  listannotation_ = p1;
  saulident_ = p2;
  listparamdecl_ = p3;
  returntype_ = p4;
  listdecl_ = p5;
  expr_ = p6;

}

DeclFun::DeclFun(const DeclFun & other)
{
  listannotation_ = other.listannotation_->clone();
  saulident_ = other.saulident_;
  listparamdecl_ = other.listparamdecl_->clone();
  returntype_ = other.returntype_->clone();
  listdecl_ = other.listdecl_->clone();
  expr_ = other.expr_->clone();

}

DeclFun &DeclFun::operator=(const DeclFun & other)
{
  DeclFun tmp(other);
  swap(tmp);
  return *this;
}

void DeclFun::swap(DeclFun & other)
{
  std::swap(listannotation_, other.listannotation_);
  std::swap(saulident_, other.saulident_);
  std::swap(listparamdecl_, other.listparamdecl_);
  std::swap(returntype_, other.returntype_);
  std::swap(listdecl_, other.listdecl_);
  std::swap(expr_, other.expr_);

}

DeclFun::~DeclFun()
{
  delete(listannotation_);
  delete(listparamdecl_);
  delete(returntype_);
  delete(listdecl_);
  delete(expr_);

}

void DeclFun::accept(Visitor *v)
{
  v->visitDeclFun(this);
}

DeclFun *DeclFun::clone() const
{
  return new DeclFun(*this);
}



/********************   ALocalDecl    ********************/
ALocalDecl::ALocalDecl(Decl *p1)
{
  decl_ = p1;

}

ALocalDecl::ALocalDecl(const ALocalDecl & other)
{
  decl_ = other.decl_->clone();

}

ALocalDecl &ALocalDecl::operator=(const ALocalDecl & other)
{
  ALocalDecl tmp(other);
  swap(tmp);
  return *this;
}

void ALocalDecl::swap(ALocalDecl & other)
{
  std::swap(decl_, other.decl_);

}

ALocalDecl::~ALocalDecl()
{
  delete(decl_);

}

void ALocalDecl::accept(Visitor *v)
{
  v->visitALocalDecl(this);
}

ALocalDecl *ALocalDecl::clone() const
{
  return new ALocalDecl(*this);
}



/********************   InlineAnnotation    ********************/
InlineAnnotation::InlineAnnotation()
{

}

InlineAnnotation::InlineAnnotation(const InlineAnnotation & other)
{

}

InlineAnnotation &InlineAnnotation::operator=(const InlineAnnotation & other)
{
  InlineAnnotation tmp(other);
  swap(tmp);
  return *this;
}

void InlineAnnotation::swap(InlineAnnotation & other)
{

}

InlineAnnotation::~InlineAnnotation()
{

}

void InlineAnnotation::accept(Visitor *v)
{
  v->visitInlineAnnotation(this);
}

InlineAnnotation *InlineAnnotation::clone() const
{
  return new InlineAnnotation(*this);
}



/********************   AParamDecl    ********************/
AParamDecl::AParamDecl(SaulIdent p1, Type *p2)
{
  saulident_ = p1;
  type_ = p2;

}

AParamDecl::AParamDecl(const AParamDecl & other)
{
  saulident_ = other.saulident_;
  type_ = other.type_->clone();

}

AParamDecl &AParamDecl::operator=(const AParamDecl & other)
{
  AParamDecl tmp(other);
  swap(tmp);
  return *this;
}

void AParamDecl::swap(AParamDecl & other)
{
  std::swap(saulident_, other.saulident_);
  std::swap(type_, other.type_);

}

AParamDecl::~AParamDecl()
{
  delete(type_);

}

void AParamDecl::accept(Visitor *v)
{
  v->visitAParamDecl(this);
}

AParamDecl *AParamDecl::clone() const
{
  return new AParamDecl(*this);
}



/********************   NoReturnType    ********************/
NoReturnType::NoReturnType()
{

}

NoReturnType::NoReturnType(const NoReturnType & other)
{

}

NoReturnType &NoReturnType::operator=(const NoReturnType & other)
{
  NoReturnType tmp(other);
  swap(tmp);
  return *this;
}

void NoReturnType::swap(NoReturnType & other)
{

}

NoReturnType::~NoReturnType()
{

}

void NoReturnType::accept(Visitor *v)
{
  v->visitNoReturnType(this);
}

NoReturnType *NoReturnType::clone() const
{
  return new NoReturnType(*this);
}



/********************   SomeReturnType    ********************/
SomeReturnType::SomeReturnType(Type *p1)
{
  type_ = p1;

}

SomeReturnType::SomeReturnType(const SomeReturnType & other)
{
  type_ = other.type_->clone();

}

SomeReturnType &SomeReturnType::operator=(const SomeReturnType & other)
{
  SomeReturnType tmp(other);
  swap(tmp);
  return *this;
}

void SomeReturnType::swap(SomeReturnType & other)
{
  std::swap(type_, other.type_);

}

SomeReturnType::~SomeReturnType()
{
  delete(type_);

}

void SomeReturnType::accept(Visitor *v)
{
  v->visitSomeReturnType(this);
}

SomeReturnType *SomeReturnType::clone() const
{
  return new SomeReturnType(*this);
}



/********************   TypeFun    ********************/
TypeFun::TypeFun(ListType *p1, Type *p2)
{
  listtype_ = p1;
  type_ = p2;

}

TypeFun::TypeFun(const TypeFun & other)
{
  listtype_ = other.listtype_->clone();
  type_ = other.type_->clone();

}

TypeFun &TypeFun::operator=(const TypeFun & other)
{
  TypeFun tmp(other);
  swap(tmp);
  return *this;
}

void TypeFun::swap(TypeFun & other)
{
  std::swap(listtype_, other.listtype_);
  std::swap(type_, other.type_);

}

TypeFun::~TypeFun()
{
  delete(listtype_);
  delete(type_);

}

void TypeFun::accept(Visitor *v)
{
  v->visitTypeFun(this);
}

TypeFun *TypeFun::clone() const
{
  return new TypeFun(*this);
}



/********************   TypeSum    ********************/
TypeSum::TypeSum(Type *p1, Type *p2)
{
  type_1 = p1;
  type_2 = p2;

}

TypeSum::TypeSum(const TypeSum & other)
{
  type_1 = other.type_1->clone();
  type_2 = other.type_2->clone();

}

TypeSum &TypeSum::operator=(const TypeSum & other)
{
  TypeSum tmp(other);
  swap(tmp);
  return *this;
}

void TypeSum::swap(TypeSum & other)
{
  std::swap(type_1, other.type_1);
  std::swap(type_2, other.type_2);

}

TypeSum::~TypeSum()
{
  delete(type_1);
  delete(type_2);

}

void TypeSum::accept(Visitor *v)
{
  v->visitTypeSum(this);
}

TypeSum *TypeSum::clone() const
{
  return new TypeSum(*this);
}



/********************   TypeTuple    ********************/
TypeTuple::TypeTuple(ListType *p1)
{
  listtype_ = p1;

}

TypeTuple::TypeTuple(const TypeTuple & other)
{
  listtype_ = other.listtype_->clone();

}

TypeTuple &TypeTuple::operator=(const TypeTuple & other)
{
  TypeTuple tmp(other);
  swap(tmp);
  return *this;
}

void TypeTuple::swap(TypeTuple & other)
{
  std::swap(listtype_, other.listtype_);

}

TypeTuple::~TypeTuple()
{
  delete(listtype_);

}

void TypeTuple::accept(Visitor *v)
{
  v->visitTypeTuple(this);
}

TypeTuple *TypeTuple::clone() const
{
  return new TypeTuple(*this);
}



/********************   TypeRecord    ********************/
TypeRecord::TypeRecord(ListRecordFieldType *p1)
{
  listrecordfieldtype_ = p1;

}

TypeRecord::TypeRecord(const TypeRecord & other)
{
  listrecordfieldtype_ = other.listrecordfieldtype_->clone();

}

TypeRecord &TypeRecord::operator=(const TypeRecord & other)
{
  TypeRecord tmp(other);
  swap(tmp);
  return *this;
}

void TypeRecord::swap(TypeRecord & other)
{
  std::swap(listrecordfieldtype_, other.listrecordfieldtype_);

}

TypeRecord::~TypeRecord()
{
  delete(listrecordfieldtype_);

}

void TypeRecord::accept(Visitor *v)
{
  v->visitTypeRecord(this);
}

TypeRecord *TypeRecord::clone() const
{
  return new TypeRecord(*this);
}



/********************   TypeBool    ********************/
TypeBool::TypeBool()
{

}

TypeBool::TypeBool(const TypeBool & other)
{

}

TypeBool &TypeBool::operator=(const TypeBool & other)
{
  TypeBool tmp(other);
  swap(tmp);
  return *this;
}

void TypeBool::swap(TypeBool & other)
{

}

TypeBool::~TypeBool()
{

}

void TypeBool::accept(Visitor *v)
{
  v->visitTypeBool(this);
}

TypeBool *TypeBool::clone() const
{
  return new TypeBool(*this);
}



/********************   TypeNat    ********************/
TypeNat::TypeNat()
{

}

TypeNat::TypeNat(const TypeNat & other)
{

}

TypeNat &TypeNat::operator=(const TypeNat & other)
{
  TypeNat tmp(other);
  swap(tmp);
  return *this;
}

void TypeNat::swap(TypeNat & other)
{

}

TypeNat::~TypeNat()
{

}

void TypeNat::accept(Visitor *v)
{
  v->visitTypeNat(this);
}

TypeNat *TypeNat::clone() const
{
  return new TypeNat(*this);
}



/********************   TypeUnit    ********************/
TypeUnit::TypeUnit()
{

}

TypeUnit::TypeUnit(const TypeUnit & other)
{

}

TypeUnit &TypeUnit::operator=(const TypeUnit & other)
{
  TypeUnit tmp(other);
  swap(tmp);
  return *this;
}

void TypeUnit::swap(TypeUnit & other)
{

}

TypeUnit::~TypeUnit()
{

}

void TypeUnit::accept(Visitor *v)
{
  v->visitTypeUnit(this);
}

TypeUnit *TypeUnit::clone() const
{
  return new TypeUnit(*this);
}



/********************   TypeTop    ********************/
TypeTop::TypeTop()
{

}

TypeTop::TypeTop(const TypeTop & other)
{

}

TypeTop &TypeTop::operator=(const TypeTop & other)
{
  TypeTop tmp(other);
  swap(tmp);
  return *this;
}

void TypeTop::swap(TypeTop & other)
{

}

TypeTop::~TypeTop()
{

}

void TypeTop::accept(Visitor *v)
{
  v->visitTypeTop(this);
}

TypeTop *TypeTop::clone() const
{
  return new TypeTop(*this);
}



/********************   TypeBottom    ********************/
TypeBottom::TypeBottom()
{

}

TypeBottom::TypeBottom(const TypeBottom & other)
{

}

TypeBottom &TypeBottom::operator=(const TypeBottom & other)
{
  TypeBottom tmp(other);
  swap(tmp);
  return *this;
}

void TypeBottom::swap(TypeBottom & other)
{

}

TypeBottom::~TypeBottom()
{

}

void TypeBottom::accept(Visitor *v)
{
  v->visitTypeBottom(this);
}

TypeBottom *TypeBottom::clone() const
{
  return new TypeBottom(*this);
}



/********************   TypeRef    ********************/
TypeRef::TypeRef(Type *p1)
{
  type_ = p1;

}

TypeRef::TypeRef(const TypeRef & other)
{
  type_ = other.type_->clone();

}

TypeRef &TypeRef::operator=(const TypeRef & other)
{
  TypeRef tmp(other);
  swap(tmp);
  return *this;
}

void TypeRef::swap(TypeRef & other)
{
  std::swap(type_, other.type_);

}

TypeRef::~TypeRef()
{
  delete(type_);

}

void TypeRef::accept(Visitor *v)
{
  v->visitTypeRef(this);
}

TypeRef *TypeRef::clone() const
{
  return new TypeRef(*this);
}



/********************   TypeVar    ********************/
TypeVar::TypeVar(SaulIdent p1)
{
  saulident_ = p1;

}

TypeVar::TypeVar(const TypeVar & other)
{
  saulident_ = other.saulident_;

}

TypeVar &TypeVar::operator=(const TypeVar & other)
{
  TypeVar tmp(other);
  swap(tmp);
  return *this;
}

void TypeVar::swap(TypeVar & other)
{
  std::swap(saulident_, other.saulident_);

}

TypeVar::~TypeVar()
{

}

void TypeVar::accept(Visitor *v)
{
  v->visitTypeVar(this);
}

TypeVar *TypeVar::clone() const
{
  return new TypeVar(*this);
}



/********************   AMatchCase    ********************/
AMatchCase::AMatchCase(Pattern *p1, Expr *p2)
{
  pattern_ = p1;
  expr_ = p2;

}

AMatchCase::AMatchCase(const AMatchCase & other)
{
  pattern_ = other.pattern_->clone();
  expr_ = other.expr_->clone();

}

AMatchCase &AMatchCase::operator=(const AMatchCase & other)
{
  AMatchCase tmp(other);
  swap(tmp);
  return *this;
}

void AMatchCase::swap(AMatchCase & other)
{
  std::swap(pattern_, other.pattern_);
  std::swap(expr_, other.expr_);

}

AMatchCase::~AMatchCase()
{
  delete(pattern_);
  delete(expr_);

}

void AMatchCase::accept(Visitor *v)
{
  v->visitAMatchCase(this);
}

AMatchCase *AMatchCase::clone() const
{
  return new AMatchCase(*this);
}



/********************   PatternInl    ********************/
PatternInl::PatternInl(Pattern *p1)
{
  pattern_ = p1;

}

PatternInl::PatternInl(const PatternInl & other)
{
  pattern_ = other.pattern_->clone();

}

PatternInl &PatternInl::operator=(const PatternInl & other)
{
  PatternInl tmp(other);
  swap(tmp);
  return *this;
}

void PatternInl::swap(PatternInl & other)
{
  std::swap(pattern_, other.pattern_);

}

PatternInl::~PatternInl()
{
  delete(pattern_);

}

void PatternInl::accept(Visitor *v)
{
  v->visitPatternInl(this);
}

PatternInl *PatternInl::clone() const
{
  return new PatternInl(*this);
}



/********************   PatternInr    ********************/
PatternInr::PatternInr(Pattern *p1)
{
  pattern_ = p1;

}

PatternInr::PatternInr(const PatternInr & other)
{
  pattern_ = other.pattern_->clone();

}

PatternInr &PatternInr::operator=(const PatternInr & other)
{
  PatternInr tmp(other);
  swap(tmp);
  return *this;
}

void PatternInr::swap(PatternInr & other)
{
  std::swap(pattern_, other.pattern_);

}

PatternInr::~PatternInr()
{
  delete(pattern_);

}

void PatternInr::accept(Visitor *v)
{
  v->visitPatternInr(this);
}

PatternInr *PatternInr::clone() const
{
  return new PatternInr(*this);
}



/********************   PatternTuple    ********************/
PatternTuple::PatternTuple(ListPattern *p1)
{
  listpattern_ = p1;

}

PatternTuple::PatternTuple(const PatternTuple & other)
{
  listpattern_ = other.listpattern_->clone();

}

PatternTuple &PatternTuple::operator=(const PatternTuple & other)
{
  PatternTuple tmp(other);
  swap(tmp);
  return *this;
}

void PatternTuple::swap(PatternTuple & other)
{
  std::swap(listpattern_, other.listpattern_);

}

PatternTuple::~PatternTuple()
{
  delete(listpattern_);

}

void PatternTuple::accept(Visitor *v)
{
  v->visitPatternTuple(this);
}

PatternTuple *PatternTuple::clone() const
{
  return new PatternTuple(*this);
}



/********************   PatternRecord    ********************/
PatternRecord::PatternRecord(ListLabelledPattern *p1)
{
  listlabelledpattern_ = p1;

}

PatternRecord::PatternRecord(const PatternRecord & other)
{
  listlabelledpattern_ = other.listlabelledpattern_->clone();

}

PatternRecord &PatternRecord::operator=(const PatternRecord & other)
{
  PatternRecord tmp(other);
  swap(tmp);
  return *this;
}

void PatternRecord::swap(PatternRecord & other)
{
  std::swap(listlabelledpattern_, other.listlabelledpattern_);

}

PatternRecord::~PatternRecord()
{
  delete(listlabelledpattern_);

}

void PatternRecord::accept(Visitor *v)
{
  v->visitPatternRecord(this);
}

PatternRecord *PatternRecord::clone() const
{
  return new PatternRecord(*this);
}



/********************   PatternFalse    ********************/
PatternFalse::PatternFalse()
{

}

PatternFalse::PatternFalse(const PatternFalse & other)
{

}

PatternFalse &PatternFalse::operator=(const PatternFalse & other)
{
  PatternFalse tmp(other);
  swap(tmp);
  return *this;
}

void PatternFalse::swap(PatternFalse & other)
{

}

PatternFalse::~PatternFalse()
{

}

void PatternFalse::accept(Visitor *v)
{
  v->visitPatternFalse(this);
}

PatternFalse *PatternFalse::clone() const
{
  return new PatternFalse(*this);
}



/********************   PatternTrue    ********************/
PatternTrue::PatternTrue()
{

}

PatternTrue::PatternTrue(const PatternTrue & other)
{

}

PatternTrue &PatternTrue::operator=(const PatternTrue & other)
{
  PatternTrue tmp(other);
  swap(tmp);
  return *this;
}

void PatternTrue::swap(PatternTrue & other)
{

}

PatternTrue::~PatternTrue()
{

}

void PatternTrue::accept(Visitor *v)
{
  v->visitPatternTrue(this);
}

PatternTrue *PatternTrue::clone() const
{
  return new PatternTrue(*this);
}



/********************   PatternUnit    ********************/
PatternUnit::PatternUnit()
{

}

PatternUnit::PatternUnit(const PatternUnit & other)
{

}

PatternUnit &PatternUnit::operator=(const PatternUnit & other)
{
  PatternUnit tmp(other);
  swap(tmp);
  return *this;
}

void PatternUnit::swap(PatternUnit & other)
{

}

PatternUnit::~PatternUnit()
{

}

void PatternUnit::accept(Visitor *v)
{
  v->visitPatternUnit(this);
}

PatternUnit *PatternUnit::clone() const
{
  return new PatternUnit(*this);
}



/********************   PatternInt    ********************/
PatternInt::PatternInt(Integer p1)
{
  integer_ = p1;

}

PatternInt::PatternInt(const PatternInt & other)
{
  integer_ = other.integer_;

}

PatternInt &PatternInt::operator=(const PatternInt & other)
{
  PatternInt tmp(other);
  swap(tmp);
  return *this;
}

void PatternInt::swap(PatternInt & other)
{
  std::swap(integer_, other.integer_);

}

PatternInt::~PatternInt()
{

}

void PatternInt::accept(Visitor *v)
{
  v->visitPatternInt(this);
}

PatternInt *PatternInt::clone() const
{
  return new PatternInt(*this);
}



/********************   PatternSucc    ********************/
PatternSucc::PatternSucc(Pattern *p1)
{
  pattern_ = p1;

}

PatternSucc::PatternSucc(const PatternSucc & other)
{
  pattern_ = other.pattern_->clone();

}

PatternSucc &PatternSucc::operator=(const PatternSucc & other)
{
  PatternSucc tmp(other);
  swap(tmp);
  return *this;
}

void PatternSucc::swap(PatternSucc & other)
{
  std::swap(pattern_, other.pattern_);

}

PatternSucc::~PatternSucc()
{
  delete(pattern_);

}

void PatternSucc::accept(Visitor *v)
{
  v->visitPatternSucc(this);
}

PatternSucc *PatternSucc::clone() const
{
  return new PatternSucc(*this);
}



/********************   PatternVar    ********************/
PatternVar::PatternVar(SaulIdent p1)
{
  saulident_ = p1;

}

PatternVar::PatternVar(const PatternVar & other)
{
  saulident_ = other.saulident_;

}

PatternVar &PatternVar::operator=(const PatternVar & other)
{
  PatternVar tmp(other);
  swap(tmp);
  return *this;
}

void PatternVar::swap(PatternVar & other)
{
  std::swap(saulident_, other.saulident_);

}

PatternVar::~PatternVar()
{

}

void PatternVar::accept(Visitor *v)
{
  v->visitPatternVar(this);
}

PatternVar *PatternVar::clone() const
{
  return new PatternVar(*this);
}



/********************   ALabelledPattern    ********************/
ALabelledPattern::ALabelledPattern(SaulIdent p1, Pattern *p2)
{
  saulident_ = p1;
  pattern_ = p2;

}

ALabelledPattern::ALabelledPattern(const ALabelledPattern & other)
{
  saulident_ = other.saulident_;
  pattern_ = other.pattern_->clone();

}

ALabelledPattern &ALabelledPattern::operator=(const ALabelledPattern & other)
{
  ALabelledPattern tmp(other);
  swap(tmp);
  return *this;
}

void ALabelledPattern::swap(ALabelledPattern & other)
{
  std::swap(saulident_, other.saulident_);
  std::swap(pattern_, other.pattern_);

}

ALabelledPattern::~ALabelledPattern()
{
  delete(pattern_);

}

void ALabelledPattern::accept(Visitor *v)
{
  v->visitALabelledPattern(this);
}

ALabelledPattern *ALabelledPattern::clone() const
{
  return new ALabelledPattern(*this);
}



/********************   ABinding    ********************/
ABinding::ABinding(SaulIdent p1, Expr *p2)
{
  saulident_ = p1;
  expr_ = p2;

}

ABinding::ABinding(const ABinding & other)
{
  saulident_ = other.saulident_;
  expr_ = other.expr_->clone();

}

ABinding &ABinding::operator=(const ABinding & other)
{
  ABinding tmp(other);
  swap(tmp);
  return *this;
}

void ABinding::swap(ABinding & other)
{
  std::swap(saulident_, other.saulident_);
  std::swap(expr_, other.expr_);

}

ABinding::~ABinding()
{
  delete(expr_);

}

void ABinding::accept(Visitor *v)
{
  v->visitABinding(this);
}

ABinding *ABinding::clone() const
{
  return new ABinding(*this);
}



/********************   Sequence    ********************/
Sequence::Sequence(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Sequence::Sequence(const Sequence & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Sequence &Sequence::operator=(const Sequence & other)
{
  Sequence tmp(other);
  swap(tmp);
  return *this;
}

void Sequence::swap(Sequence & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Sequence::~Sequence()
{
  delete(expr_1);
  delete(expr_2);

}

void Sequence::accept(Visitor *v)
{
  v->visitSequence(this);
}

Sequence *Sequence::clone() const
{
  return new Sequence(*this);
}



/********************   Assign    ********************/
Assign::Assign(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Assign::Assign(const Assign & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Assign &Assign::operator=(const Assign & other)
{
  Assign tmp(other);
  swap(tmp);
  return *this;
}

void Assign::swap(Assign & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Assign::~Assign()
{
  delete(expr_1);
  delete(expr_2);

}

void Assign::accept(Visitor *v)
{
  v->visitAssign(this);
}

Assign *Assign::clone() const
{
  return new Assign(*this);
}



/********************   If    ********************/
If::If(Expr *p1, Expr *p2, Expr *p3)
{
  expr_1 = p1;
  expr_2 = p2;
  expr_3 = p3;

}

If::If(const If & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();
  expr_3 = other.expr_3->clone();

}

If &If::operator=(const If & other)
{
  If tmp(other);
  swap(tmp);
  return *this;
}

void If::swap(If & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);
  std::swap(expr_3, other.expr_3);

}

If::~If()
{
  delete(expr_1);
  delete(expr_2);
  delete(expr_3);

}

void If::accept(Visitor *v)
{
  v->visitIf(this);
}

If *If::clone() const
{
  return new If(*this);
}



/********************   LessThan    ********************/
LessThan::LessThan(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LessThan::LessThan(const LessThan & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LessThan &LessThan::operator=(const LessThan & other)
{
  LessThan tmp(other);
  swap(tmp);
  return *this;
}

void LessThan::swap(LessThan & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LessThan::~LessThan()
{
  delete(expr_1);
  delete(expr_2);

}

void LessThan::accept(Visitor *v)
{
  v->visitLessThan(this);
}

LessThan *LessThan::clone() const
{
  return new LessThan(*this);
}



/********************   LessThanOrEqual    ********************/
LessThanOrEqual::LessThanOrEqual(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LessThanOrEqual::LessThanOrEqual(const LessThanOrEqual & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LessThanOrEqual &LessThanOrEqual::operator=(const LessThanOrEqual & other)
{
  LessThanOrEqual tmp(other);
  swap(tmp);
  return *this;
}

void LessThanOrEqual::swap(LessThanOrEqual & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LessThanOrEqual::~LessThanOrEqual()
{
  delete(expr_1);
  delete(expr_2);

}

void LessThanOrEqual::accept(Visitor *v)
{
  v->visitLessThanOrEqual(this);
}

LessThanOrEqual *LessThanOrEqual::clone() const
{
  return new LessThanOrEqual(*this);
}



/********************   GreaterThan    ********************/
GreaterThan::GreaterThan(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

GreaterThan::GreaterThan(const GreaterThan & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

GreaterThan &GreaterThan::operator=(const GreaterThan & other)
{
  GreaterThan tmp(other);
  swap(tmp);
  return *this;
}

void GreaterThan::swap(GreaterThan & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

GreaterThan::~GreaterThan()
{
  delete(expr_1);
  delete(expr_2);

}

void GreaterThan::accept(Visitor *v)
{
  v->visitGreaterThan(this);
}

GreaterThan *GreaterThan::clone() const
{
  return new GreaterThan(*this);
}



/********************   GreaterThanOrEqual    ********************/
GreaterThanOrEqual::GreaterThanOrEqual(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

GreaterThanOrEqual::GreaterThanOrEqual(const GreaterThanOrEqual & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

GreaterThanOrEqual &GreaterThanOrEqual::operator=(const GreaterThanOrEqual & other)
{
  GreaterThanOrEqual tmp(other);
  swap(tmp);
  return *this;
}

void GreaterThanOrEqual::swap(GreaterThanOrEqual & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

GreaterThanOrEqual::~GreaterThanOrEqual()
{
  delete(expr_1);
  delete(expr_2);

}

void GreaterThanOrEqual::accept(Visitor *v)
{
  v->visitGreaterThanOrEqual(this);
}

GreaterThanOrEqual *GreaterThanOrEqual::clone() const
{
  return new GreaterThanOrEqual(*this);
}



/********************   Equal    ********************/
Equal::Equal(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Equal::Equal(const Equal & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Equal &Equal::operator=(const Equal & other)
{
  Equal tmp(other);
  swap(tmp);
  return *this;
}

void Equal::swap(Equal & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Equal::~Equal()
{
  delete(expr_1);
  delete(expr_2);

}

void Equal::accept(Visitor *v)
{
  v->visitEqual(this);
}

Equal *Equal::clone() const
{
  return new Equal(*this);
}



/********************   NotEqual    ********************/
NotEqual::NotEqual(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

NotEqual::NotEqual(const NotEqual & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

NotEqual &NotEqual::operator=(const NotEqual & other)
{
  NotEqual tmp(other);
  swap(tmp);
  return *this;
}

void NotEqual::swap(NotEqual & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

NotEqual::~NotEqual()
{
  delete(expr_1);
  delete(expr_2);

}

void NotEqual::accept(Visitor *v)
{
  v->visitNotEqual(this);
}

NotEqual *NotEqual::clone() const
{
  return new NotEqual(*this);
}



/********************   Abstraction    ********************/
Abstraction::Abstraction(ListParamDecl *p1, Expr *p2)
{
  listparamdecl_ = p1;
  expr_ = p2;

}

Abstraction::Abstraction(const Abstraction & other)
{
  listparamdecl_ = other.listparamdecl_->clone();
  expr_ = other.expr_->clone();

}

Abstraction &Abstraction::operator=(const Abstraction & other)
{
  Abstraction tmp(other);
  swap(tmp);
  return *this;
}

void Abstraction::swap(Abstraction & other)
{
  std::swap(listparamdecl_, other.listparamdecl_);
  std::swap(expr_, other.expr_);

}

Abstraction::~Abstraction()
{
  delete(listparamdecl_);
  delete(expr_);

}

void Abstraction::accept(Visitor *v)
{
  v->visitAbstraction(this);
}

Abstraction *Abstraction::clone() const
{
  return new Abstraction(*this);
}



/********************   Match    ********************/
Match::Match(Expr *p1, ListMatchCase *p2)
{
  expr_ = p1;
  listmatchcase_ = p2;

}

Match::Match(const Match & other)
{
  expr_ = other.expr_->clone();
  listmatchcase_ = other.listmatchcase_->clone();

}

Match &Match::operator=(const Match & other)
{
  Match tmp(other);
  swap(tmp);
  return *this;
}

void Match::swap(Match & other)
{
  std::swap(expr_, other.expr_);
  std::swap(listmatchcase_, other.listmatchcase_);

}

Match::~Match()
{
  delete(expr_);
  delete(listmatchcase_);

}

void Match::accept(Visitor *v)
{
  v->visitMatch(this);
}

Match *Match::clone() const
{
  return new Match(*this);
}



/********************   Add    ********************/
Add::Add(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Add::Add(const Add & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Add &Add::operator=(const Add & other)
{
  Add tmp(other);
  swap(tmp);
  return *this;
}

void Add::swap(Add & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Add::~Add()
{
  delete(expr_1);
  delete(expr_2);

}

void Add::accept(Visitor *v)
{
  v->visitAdd(this);
}

Add *Add::clone() const
{
  return new Add(*this);
}



/********************   Subtract    ********************/
Subtract::Subtract(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Subtract::Subtract(const Subtract & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Subtract &Subtract::operator=(const Subtract & other)
{
  Subtract tmp(other);
  swap(tmp);
  return *this;
}

void Subtract::swap(Subtract & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Subtract::~Subtract()
{
  delete(expr_1);
  delete(expr_2);

}

void Subtract::accept(Visitor *v)
{
  v->visitSubtract(this);
}

Subtract *Subtract::clone() const
{
  return new Subtract(*this);
}



/********************   LogicOr    ********************/
LogicOr::LogicOr(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicOr::LogicOr(const LogicOr & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicOr &LogicOr::operator=(const LogicOr & other)
{
  LogicOr tmp(other);
  swap(tmp);
  return *this;
}

void LogicOr::swap(LogicOr & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicOr::~LogicOr()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicOr::accept(Visitor *v)
{
  v->visitLogicOr(this);
}

LogicOr *LogicOr::clone() const
{
  return new LogicOr(*this);
}



/********************   Multiply    ********************/
Multiply::Multiply(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Multiply::Multiply(const Multiply & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Multiply &Multiply::operator=(const Multiply & other)
{
  Multiply tmp(other);
  swap(tmp);
  return *this;
}

void Multiply::swap(Multiply & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Multiply::~Multiply()
{
  delete(expr_1);
  delete(expr_2);

}

void Multiply::accept(Visitor *v)
{
  v->visitMultiply(this);
}

Multiply *Multiply::clone() const
{
  return new Multiply(*this);
}



/********************   Divide    ********************/
Divide::Divide(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

Divide::Divide(const Divide & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

Divide &Divide::operator=(const Divide & other)
{
  Divide tmp(other);
  swap(tmp);
  return *this;
}

void Divide::swap(Divide & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

Divide::~Divide()
{
  delete(expr_1);
  delete(expr_2);

}

void Divide::accept(Visitor *v)
{
  v->visitDivide(this);
}

Divide *Divide::clone() const
{
  return new Divide(*this);
}



/********************   LogicAnd    ********************/
LogicAnd::LogicAnd(Expr *p1, Expr *p2)
{
  expr_1 = p1;
  expr_2 = p2;

}

LogicAnd::LogicAnd(const LogicAnd & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();

}

LogicAnd &LogicAnd::operator=(const LogicAnd & other)
{
  LogicAnd tmp(other);
  swap(tmp);
  return *this;
}

void LogicAnd::swap(LogicAnd & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);

}

LogicAnd::~LogicAnd()
{
  delete(expr_1);
  delete(expr_2);

}

void LogicAnd::accept(Visitor *v)
{
  v->visitLogicAnd(this);
}

LogicAnd *LogicAnd::clone() const
{
  return new LogicAnd(*this);
}



/********************   Ref    ********************/
Ref::Ref(Expr *p1)
{
  expr_ = p1;

}

Ref::Ref(const Ref & other)
{
  expr_ = other.expr_->clone();

}

Ref &Ref::operator=(const Ref & other)
{
  Ref tmp(other);
  swap(tmp);
  return *this;
}

void Ref::swap(Ref & other)
{
  std::swap(expr_, other.expr_);

}

Ref::~Ref()
{
  delete(expr_);

}

void Ref::accept(Visitor *v)
{
  v->visitRef(this);
}

Ref *Ref::clone() const
{
  return new Ref(*this);
}



/********************   Deref    ********************/
Deref::Deref(Expr *p1)
{
  expr_ = p1;

}

Deref::Deref(const Deref & other)
{
  expr_ = other.expr_->clone();

}

Deref &Deref::operator=(const Deref & other)
{
  Deref tmp(other);
  swap(tmp);
  return *this;
}

void Deref::swap(Deref & other)
{
  std::swap(expr_, other.expr_);

}

Deref::~Deref()
{
  delete(expr_);

}

void Deref::accept(Visitor *v)
{
  v->visitDeref(this);
}

Deref *Deref::clone() const
{
  return new Deref(*this);
}



/********************   Application    ********************/
Application::Application(Expr *p1, ListExpr *p2)
{
  expr_ = p1;
  listexpr_ = p2;

}

Application::Application(const Application & other)
{
  expr_ = other.expr_->clone();
  listexpr_ = other.listexpr_->clone();

}

Application &Application::operator=(const Application & other)
{
  Application tmp(other);
  swap(tmp);
  return *this;
}

void Application::swap(Application & other)
{
  std::swap(expr_, other.expr_);
  std::swap(listexpr_, other.listexpr_);

}

Application::~Application()
{
  delete(expr_);
  delete(listexpr_);

}

void Application::accept(Visitor *v)
{
  v->visitApplication(this);
}

Application *Application::clone() const
{
  return new Application(*this);
}



/********************   DotRecord    ********************/
DotRecord::DotRecord(Expr *p1, SaulIdent p2)
{
  expr_ = p1;
  saulident_ = p2;

}

DotRecord::DotRecord(const DotRecord & other)
{
  expr_ = other.expr_->clone();
  saulident_ = other.saulident_;

}

DotRecord &DotRecord::operator=(const DotRecord & other)
{
  DotRecord tmp(other);
  swap(tmp);
  return *this;
}

void DotRecord::swap(DotRecord & other)
{
  std::swap(expr_, other.expr_);
  std::swap(saulident_, other.saulident_);

}

DotRecord::~DotRecord()
{
  delete(expr_);

}

void DotRecord::accept(Visitor *v)
{
  v->visitDotRecord(this);
}

DotRecord *DotRecord::clone() const
{
  return new DotRecord(*this);
}



/********************   DotTuple    ********************/
DotTuple::DotTuple(Expr *p1, Integer p2)
{
  expr_ = p1;
  integer_ = p2;

}

DotTuple::DotTuple(const DotTuple & other)
{
  expr_ = other.expr_->clone();
  integer_ = other.integer_;

}

DotTuple &DotTuple::operator=(const DotTuple & other)
{
  DotTuple tmp(other);
  swap(tmp);
  return *this;
}

void DotTuple::swap(DotTuple & other)
{
  std::swap(expr_, other.expr_);
  std::swap(integer_, other.integer_);

}

DotTuple::~DotTuple()
{
  delete(expr_);

}

void DotTuple::accept(Visitor *v)
{
  v->visitDotTuple(this);
}

DotTuple *DotTuple::clone() const
{
  return new DotTuple(*this);
}



/********************   Tuple    ********************/
Tuple::Tuple(ListExpr *p1)
{
  listexpr_ = p1;

}

Tuple::Tuple(const Tuple & other)
{
  listexpr_ = other.listexpr_->clone();

}

Tuple &Tuple::operator=(const Tuple & other)
{
  Tuple tmp(other);
  swap(tmp);
  return *this;
}

void Tuple::swap(Tuple & other)
{
  std::swap(listexpr_, other.listexpr_);

}

Tuple::~Tuple()
{
  delete(listexpr_);

}

void Tuple::accept(Visitor *v)
{
  v->visitTuple(this);
}

Tuple *Tuple::clone() const
{
  return new Tuple(*this);
}



/********************   Record    ********************/
Record::Record(ListBinding *p1)
{
  listbinding_ = p1;

}

Record::Record(const Record & other)
{
  listbinding_ = other.listbinding_->clone();

}

Record &Record::operator=(const Record & other)
{
  Record tmp(other);
  swap(tmp);
  return *this;
}

void Record::swap(Record & other)
{
  std::swap(listbinding_, other.listbinding_);

}

Record::~Record()
{
  delete(listbinding_);

}

void Record::accept(Visitor *v)
{
  v->visitRecord(this);
}

Record *Record::clone() const
{
  return new Record(*this);
}



/********************   Panic    ********************/
Panic::Panic()
{

}

Panic::Panic(const Panic & other)
{

}

Panic &Panic::operator=(const Panic & other)
{
  Panic tmp(other);
  swap(tmp);
  return *this;
}

void Panic::swap(Panic & other)
{

}

Panic::~Panic()
{

}

void Panic::accept(Visitor *v)
{
  v->visitPanic(this);
}

Panic *Panic::clone() const
{
  return new Panic(*this);
}



/********************   Inl    ********************/
Inl::Inl(Expr *p1)
{
  expr_ = p1;

}

Inl::Inl(const Inl & other)
{
  expr_ = other.expr_->clone();

}

Inl &Inl::operator=(const Inl & other)
{
  Inl tmp(other);
  swap(tmp);
  return *this;
}

void Inl::swap(Inl & other)
{
  std::swap(expr_, other.expr_);

}

Inl::~Inl()
{
  delete(expr_);

}

void Inl::accept(Visitor *v)
{
  v->visitInl(this);
}

Inl *Inl::clone() const
{
  return new Inl(*this);
}



/********************   Inr    ********************/
Inr::Inr(Expr *p1)
{
  expr_ = p1;

}

Inr::Inr(const Inr & other)
{
  expr_ = other.expr_->clone();

}

Inr &Inr::operator=(const Inr & other)
{
  Inr tmp(other);
  swap(tmp);
  return *this;
}

void Inr::swap(Inr & other)
{
  std::swap(expr_, other.expr_);

}

Inr::~Inr()
{
  delete(expr_);

}

void Inr::accept(Visitor *v)
{
  v->visitInr(this);
}

Inr *Inr::clone() const
{
  return new Inr(*this);
}



/********************   Succ    ********************/
Succ::Succ(Expr *p1)
{
  expr_ = p1;

}

Succ::Succ(const Succ & other)
{
  expr_ = other.expr_->clone();

}

Succ &Succ::operator=(const Succ & other)
{
  Succ tmp(other);
  swap(tmp);
  return *this;
}

void Succ::swap(Succ & other)
{
  std::swap(expr_, other.expr_);

}

Succ::~Succ()
{
  delete(expr_);

}

void Succ::accept(Visitor *v)
{
  v->visitSucc(this);
}

Succ *Succ::clone() const
{
  return new Succ(*this);
}



/********************   LogicNot    ********************/
LogicNot::LogicNot(Expr *p1)
{
  expr_ = p1;

}

LogicNot::LogicNot(const LogicNot & other)
{
  expr_ = other.expr_->clone();

}

LogicNot &LogicNot::operator=(const LogicNot & other)
{
  LogicNot tmp(other);
  swap(tmp);
  return *this;
}

void LogicNot::swap(LogicNot & other)
{
  std::swap(expr_, other.expr_);

}

LogicNot::~LogicNot()
{
  delete(expr_);

}

void LogicNot::accept(Visitor *v)
{
  v->visitLogicNot(this);
}

LogicNot *LogicNot::clone() const
{
  return new LogicNot(*this);
}



/********************   Pred    ********************/
Pred::Pred(Expr *p1)
{
  expr_ = p1;

}

Pred::Pred(const Pred & other)
{
  expr_ = other.expr_->clone();

}

Pred &Pred::operator=(const Pred & other)
{
  Pred tmp(other);
  swap(tmp);
  return *this;
}

void Pred::swap(Pred & other)
{
  std::swap(expr_, other.expr_);

}

Pred::~Pred()
{
  delete(expr_);

}

void Pred::accept(Visitor *v)
{
  v->visitPred(this);
}

Pred *Pred::clone() const
{
  return new Pred(*this);
}



/********************   IsZero    ********************/
IsZero::IsZero(Expr *p1)
{
  expr_ = p1;

}

IsZero::IsZero(const IsZero & other)
{
  expr_ = other.expr_->clone();

}

IsZero &IsZero::operator=(const IsZero & other)
{
  IsZero tmp(other);
  swap(tmp);
  return *this;
}

void IsZero::swap(IsZero & other)
{
  std::swap(expr_, other.expr_);

}

IsZero::~IsZero()
{
  delete(expr_);

}

void IsZero::accept(Visitor *v)
{
  v->visitIsZero(this);
}

IsZero *IsZero::clone() const
{
  return new IsZero(*this);
}



/********************   NatRec    ********************/
NatRec::NatRec(Expr *p1, Expr *p2, Expr *p3)
{
  expr_1 = p1;
  expr_2 = p2;
  expr_3 = p3;

}

NatRec::NatRec(const NatRec & other)
{
  expr_1 = other.expr_1->clone();
  expr_2 = other.expr_2->clone();
  expr_3 = other.expr_3->clone();

}

NatRec &NatRec::operator=(const NatRec & other)
{
  NatRec tmp(other);
  swap(tmp);
  return *this;
}

void NatRec::swap(NatRec & other)
{
  std::swap(expr_1, other.expr_1);
  std::swap(expr_2, other.expr_2);
  std::swap(expr_3, other.expr_3);

}

NatRec::~NatRec()
{
  delete(expr_1);
  delete(expr_2);
  delete(expr_3);

}

void NatRec::accept(Visitor *v)
{
  v->visitNatRec(this);
}

NatRec *NatRec::clone() const
{
  return new NatRec(*this);
}



/********************   ConstTrue    ********************/
ConstTrue::ConstTrue()
{

}

ConstTrue::ConstTrue(const ConstTrue & other)
{

}

ConstTrue &ConstTrue::operator=(const ConstTrue & other)
{
  ConstTrue tmp(other);
  swap(tmp);
  return *this;
}

void ConstTrue::swap(ConstTrue & other)
{

}

ConstTrue::~ConstTrue()
{

}

void ConstTrue::accept(Visitor *v)
{
  v->visitConstTrue(this);
}

ConstTrue *ConstTrue::clone() const
{
  return new ConstTrue(*this);
}



/********************   ConstFalse    ********************/
ConstFalse::ConstFalse()
{

}

ConstFalse::ConstFalse(const ConstFalse & other)
{

}

ConstFalse &ConstFalse::operator=(const ConstFalse & other)
{
  ConstFalse tmp(other);
  swap(tmp);
  return *this;
}

void ConstFalse::swap(ConstFalse & other)
{

}

ConstFalse::~ConstFalse()
{

}

void ConstFalse::accept(Visitor *v)
{
  v->visitConstFalse(this);
}

ConstFalse *ConstFalse::clone() const
{
  return new ConstFalse(*this);
}



/********************   ConstUnit    ********************/
ConstUnit::ConstUnit()
{

}

ConstUnit::ConstUnit(const ConstUnit & other)
{

}

ConstUnit &ConstUnit::operator=(const ConstUnit & other)
{
  ConstUnit tmp(other);
  swap(tmp);
  return *this;
}

void ConstUnit::swap(ConstUnit & other)
{

}

ConstUnit::~ConstUnit()
{

}

void ConstUnit::accept(Visitor *v)
{
  v->visitConstUnit(this);
}

ConstUnit *ConstUnit::clone() const
{
  return new ConstUnit(*this);
}



/********************   ConstInt    ********************/
ConstInt::ConstInt(Integer p1)
{
  integer_ = p1;

}

ConstInt::ConstInt(const ConstInt & other)
{
  integer_ = other.integer_;

}

ConstInt &ConstInt::operator=(const ConstInt & other)
{
  ConstInt tmp(other);
  swap(tmp);
  return *this;
}

void ConstInt::swap(ConstInt & other)
{
  std::swap(integer_, other.integer_);

}

ConstInt::~ConstInt()
{

}

void ConstInt::accept(Visitor *v)
{
  v->visitConstInt(this);
}

ConstInt *ConstInt::clone() const
{
  return new ConstInt(*this);
}



/********************   Var    ********************/
Var::Var(SaulIdent p1)
{
  saulident_ = p1;

}

Var::Var(const Var & other)
{
  saulident_ = other.saulident_;

}

Var &Var::operator=(const Var & other)
{
  Var tmp(other);
  swap(tmp);
  return *this;
}

void Var::swap(Var & other)
{
  std::swap(saulident_, other.saulident_);

}

Var::~Var()
{

}

void Var::accept(Visitor *v)
{
  v->visitVar(this);
}

Var *Var::clone() const
{
  return new Var(*this);
}



/********************   ARecordFieldType    ********************/
ARecordFieldType::ARecordFieldType(SaulIdent p1, Type *p2)
{
  saulident_ = p1;
  type_ = p2;

}

ARecordFieldType::ARecordFieldType(const ARecordFieldType & other)
{
  saulident_ = other.saulident_;
  type_ = other.type_->clone();

}

ARecordFieldType &ARecordFieldType::operator=(const ARecordFieldType & other)
{
  ARecordFieldType tmp(other);
  swap(tmp);
  return *this;
}

void ARecordFieldType::swap(ARecordFieldType & other)
{
  std::swap(saulident_, other.saulident_);
  std::swap(type_, other.type_);

}

ARecordFieldType::~ARecordFieldType()
{
  delete(type_);

}

void ARecordFieldType::accept(Visitor *v)
{
  v->visitARecordFieldType(this);
}

ARecordFieldType *ARecordFieldType::clone() const
{
  return new ARecordFieldType(*this);
}




/********************   ListSaulIdent    ********************/

void ListSaulIdent::accept(Visitor *v)
{
  v->visitListSaulIdent(this);
}

ListSaulIdent *ListSaulIdent::clone() const
{
  return new ListSaulIdent(*this);
}

ListSaulIdent* consListSaulIdent(SaulIdent x, ListSaulIdent* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListDecl    ********************/

void ListDecl::accept(Visitor *v)
{
  v->visitListDecl(this);
}

ListDecl *ListDecl::clone() const
{
  return new ListDecl(*this);
}

ListDecl* consListDecl(Decl* x, ListDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLocalDecl    ********************/

void ListLocalDecl::accept(Visitor *v)
{
  v->visitListLocalDecl(this);
}

ListLocalDecl *ListLocalDecl::clone() const
{
  return new ListLocalDecl(*this);
}

ListLocalDecl* consListLocalDecl(LocalDecl* x, ListLocalDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListAnnotation    ********************/

void ListAnnotation::accept(Visitor *v)
{
  v->visitListAnnotation(this);
}

ListAnnotation *ListAnnotation::clone() const
{
  return new ListAnnotation(*this);
}

ListAnnotation* consListAnnotation(Annotation* x, ListAnnotation* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListParamDecl    ********************/

void ListParamDecl::accept(Visitor *v)
{
  v->visitListParamDecl(this);
}

ListParamDecl *ListParamDecl::clone() const
{
  return new ListParamDecl(*this);
}

ListParamDecl* consListParamDecl(ParamDecl* x, ListParamDecl* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListType    ********************/

void ListType::accept(Visitor *v)
{
  v->visitListType(this);
}

ListType *ListType::clone() const
{
  return new ListType(*this);
}

ListType* consListType(Type* x, ListType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListMatchCase    ********************/

void ListMatchCase::accept(Visitor *v)
{
  v->visitListMatchCase(this);
}

ListMatchCase *ListMatchCase::clone() const
{
  return new ListMatchCase(*this);
}

ListMatchCase* consListMatchCase(MatchCase* x, ListMatchCase* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListPattern    ********************/

void ListPattern::accept(Visitor *v)
{
  v->visitListPattern(this);
}

ListPattern *ListPattern::clone() const
{
  return new ListPattern(*this);
}

ListPattern* consListPattern(Pattern* x, ListPattern* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListLabelledPattern    ********************/

void ListLabelledPattern::accept(Visitor *v)
{
  v->visitListLabelledPattern(this);
}

ListLabelledPattern *ListLabelledPattern::clone() const
{
  return new ListLabelledPattern(*this);
}

ListLabelledPattern* consListLabelledPattern(LabelledPattern* x, ListLabelledPattern* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListBinding    ********************/

void ListBinding::accept(Visitor *v)
{
  v->visitListBinding(this);
}

ListBinding *ListBinding::clone() const
{
  return new ListBinding(*this);
}

ListBinding* consListBinding(Binding* x, ListBinding* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListExpr    ********************/

void ListExpr::accept(Visitor *v)
{
  v->visitListExpr(this);
}

ListExpr *ListExpr::clone() const
{
  return new ListExpr(*this);
}

ListExpr* consListExpr(Expr* x, ListExpr* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}


/********************   ListRecordFieldType    ********************/

void ListRecordFieldType::accept(Visitor *v)
{
  v->visitListRecordFieldType(this);
}

ListRecordFieldType *ListRecordFieldType::clone() const
{
  return new ListRecordFieldType(*this);
}

ListRecordFieldType* consListRecordFieldType(RecordFieldType* x, ListRecordFieldType* xs) {
  xs->insert(xs->begin(), x);
  return xs;
}




}
